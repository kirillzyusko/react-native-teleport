"use strict";(self.webpackChunkreact_native_teleport_docs=self.webpackChunkreact_native_teleport_docs||[]).push([[595],{1905:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"recipes/instagram-shared-transitions","title":"Building Instagram-like Transitions","description":"Build Instagram-like shared transitions between a feed and full-screen reels viewer using react-native-teleport.","source":"@site/docs/recipes/instagram-shared-transitions.mdx","sourceDirName":"recipes","slug":"/recipes/instagram-shared-transitions","permalink":"/react-native-teleport/pr-preview/pr-92/docs/recipes/instagram-shared-transitions","draft":false,"unlisted":false,"editUrl":"https://github.com/kirillzyusko/react-native-teleport/tree/main/docs/docs/recipes/instagram-shared-transitions.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"description":"Build Instagram-like shared transitions between a feed and full-screen reels viewer using react-native-teleport.","keywords":["react-native-teleport","react-native portal","shared element transition","instagram reels","react-navigation","teleport","reparenting","hero transition","native stack","video transition","react-native-reanimated"]},"sidebar":"tutorialSidebar","previous":{"title":"Working with Modals","permalink":"/react-native-teleport/pr-preview/pr-92/docs/recipes/modals/"},"next":{"title":"API Reference","permalink":"/react-native-teleport/pr-preview/pr-92/docs/category/api-reference"}}');var i=t(4848),o=t(8453),r=t(9026),a=t(6025);const l={sidebar_position:3,description:"Build Instagram-like shared transitions between a feed and full-screen reels viewer using react-native-teleport.",keywords:["react-native-teleport","react-native portal","shared element transition","instagram reels","react-navigation","teleport","reparenting","hero transition","native stack","video transition","react-native-reanimated"]},d="Building Instagram-like Transitions",c={},h=[{value:"How it works \u2014 the big picture",id:"how-it-works--the-big-picture",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Step 1: Build the basic layout",id:"step-1-build-the-basic-layout",level:2},{value:"Define constants",id:"define-constants",level:3},{value:"Define post data",id:"define-post-data",level:3},{value:"Build the <code>Post</code> component",id:"build-the-post-component",level:3},{value:"Build the <code>Feed</code> screen",id:"build-the-feed-screen",level:3},{value:"Build the <code>Reels</code> screen",id:"build-the-reels-screen",level:3},{value:"Step 2: Add navigation (without shared transitions)",id:"step-2-add-navigation-without-shared-transitions",level:2},{value:"Why <code>transparentModal</code>?",id:"why-transparentmodal",level:3},{value:"Configure the navigator",id:"configure-the-navigator",level:3},{value:"Add tap handling to <code>Post</code>",id:"add-tap-handling-to-post",level:3},{value:"Step 3: Add the <code>teleport</code> infrastructure",id:"step-3-add-the-teleport-infrastructure",level:2},{value:"The transition store",id:"the-transition-store",level:3},{value:"Set up the root <code>PortalHost</code>",id:"set-up-the-root-portalhost",level:3},{value:"The <code>useMeasure</code> hook",id:"the-usemeasure-hook",level:3},{value:"Step 4: Add the <code>&lt;Portal&gt;</code> to share videos between screens",id:"step-4-add-the-portal-to-share-videos-between-screens",level:2},{value:"Update the <code>Post</code> component",id:"update-the-post-component",level:3},{value:"Why keep the container height fixed?",id:"why-keep-the-container-height-fixed",level:3},{value:"Add a <code>PortalHost</code> in the <code>Reels</code> screen",id:"add-a-portalhost-in-the-reels-screen",level:3},{value:"Update the <code>Feed</code> and <code>Reels</code> screens to disable scroll during transitions",id:"update-the-feed-and-reels-screens-to-disable-scroll-during-transitions",level:3},{value:"Add the <code>ReelsHeader</code> with back navigation",id:"add-the-reelsheader-with-back-navigation",level:3},{value:"Platform-specific rendering for floating elements",id:"platform-specific-rendering-for-floating-elements",level:3},{value:"The complete transition flow",id:"the-complete-transition-flow",level:2},{value:"Summary",id:"summary",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"building-instagram-like-transitions",children:"Building Instagram-like Transitions"})}),"\n",(0,i.jsx)(n.p,{children:"In this guide we'll recreate the transition Instagram uses when you tap a video in your feed and it smoothly expands into a full-screen Reels viewer. When you go back, the video shrinks back into its original position \u2014 all without interrupting playback."}),"\n",(0,i.jsx)(n.p,{children:"We'll use iOS as our reference and replicate the transition across iOS, Android, and web, so that navigation on all three platforms delivers the same polished experience."}),"\n","\n",(0,i.jsx)(r.A,{src:"/video/instagram.mov",width:35}),"\n",(0,i.jsx)(n.h2,{id:"how-it-works--the-big-picture",children:"How it works \u2014 the big picture"}),"\n",(0,i.jsxs)(n.p,{children:["The core idea is simple: ",(0,i.jsx)(n.strong,{children:"there is only one video instance, and we move it between screens"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Traditional navigation would unmount the feed screen's video and mount a brand-new one on the Reels screen. That causes a visible flash, resets playback, and makes a smooth transition impossible."}),"\n",(0,i.jsxs)(n.p,{children:["With ",(0,i.jsx)(n.code,{children:"react-native-teleport"}),", we take a different approach:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The video lives inside a ",(0,i.jsx)(n.code,{children:"<Portal>"})," in the Feed screen."]}),"\n",(0,i.jsxs)(n.li,{children:["When the user taps, we ",(0,i.jsx)(n.strong,{children:"teleport"})," the video to an overlay layer that sits above all screens."]}),"\n",(0,i.jsx)(n.li,{children:"While in the overlay, we animate the video from its card size to full-screen."}),"\n",(0,i.jsxs)(n.li,{children:["Once the animation completes, we teleport the video into a ",(0,i.jsx)(n.code,{children:"<PortalHost>"})," inside the Reels screen."]}),"\n",(0,i.jsx)(n.li,{children:"Going back reverses the process: teleport to overlay \u2192 animate back to card size \u2192 return to feed."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Because the video is ",(0,i.jsx)(n.strong,{children:"re-parented"})," (moved in the native view hierarchy) rather than unmounted/remounted, playback is never interrupted, animations stay alive, and the transition feels seamless."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Feed (in-place) \u2500\u2500tap\u2500\u2500\u25b6 Overlay (animating) \u2500\u2500done\u2500\u2500\u25b6 Reels (in-place)\n                                                              \u2502\n                         Overlay (animating) \u25c0\u2500\u2500back\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\nFeed (in-place) \u25c0\u2500\u2500done\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(n.p,{children:"This guide assumes you have a React Native project with the following libraries installed:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../installation",children:(0,i.jsx)(n.code,{children:"react-native-teleport"})})," \u2014 the star of the show"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://reactnavigation.org/docs/native-stack-navigator/",children:(0,i.jsx)(n.code,{children:"@react-navigation/native-stack"})})," \u2014 for navigation (but you can use ",(0,i.jsx)(n.strong,{children:"any"})," navigation library)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://docs.swmansion.com/react-native-reanimated/",children:(0,i.jsx)(n.code,{children:"react-native-reanimated"})})," \u2014 for smooth animations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://docs.thewidlarzgroup.com/react-native-video",children:(0,i.jsx)(n.code,{children:"react-native-video"})})," \u2014 for video playback (but you can use other libraries)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://zustand.docs.pmnd.rs/",children:(0,i.jsx)(n.code,{children:"zustand"})})," \u2014 for lightweight state management"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"step-1-build-the-basic-layout",children:"Step 1: Build the basic layout"}),"\n",(0,i.jsx)(n.p,{children:"Let's start with a static feed \u2014 no navigation, no transitions, just layout."}),"\n",(0,i.jsx)(n.h3,{id:"define-constants",children:"Define constants"}),"\n",(0,i.jsx)(n.p,{children:"First, define the dimensions we'll use throughout:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="constants.ts"',children:'import { Dimensions } from "react-native";\n\nexport const SCREEN_HEIGHT = Dimensions.get("screen").height;\n// instagram doesn\'t stretch video/images feed to full screen width on web\n// so `540` max width for web\nexport const SCREEN_WIDTH = Math.min(Dimensions.get("screen").width, 540);\nexport const ASPECT_RATIO = 3 / 4;\nexport const VIDEO_HEIGHT = SCREEN_WIDTH / ASPECT_RATIO;\nexport const CARD_HEIGHT = VIDEO_HEIGHT + 100; // video + social section below\n'})}),"\n",(0,i.jsx)(n.h3,{id:"define-post-data",children:"Define post data"}),"\n",(0,i.jsx)(n.p,{children:"Create a simple data model for posts. Each post can have either a video or a photo:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="posts.ts"',children:'export type PostType = {\n  id: number;\n  author: string;\n  text: string;\n  likes: number;\n  comments: number;\n  video?: ReturnType<typeof require>;\n  photo?: string;\n  date: string;\n  sent: number;\n};\n\nexport const posts: PostType[] = [\n  {\n    id: 1,\n    author: "kirillzyusko",\n    text: "Magic forest",\n    likes: 126,\n    comments: 12,\n    sent: 31,\n    video: require("./videos/forest.mp4"),\n    date: "29 October",\n  },\n  // ... more posts\n];\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"build-the-post-component",children:["Build the ",(0,i.jsx)(n.code,{children:"Post"})," component"]}),"\n",(0,i.jsx)(n.p,{children:"Each post card shows a video (or image) with a social section underneath:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="Post.tsx"',children:'import { View, StyleSheet, Image } from "react-native";\nimport Video from "react-native-video";\nimport {\n  VIDEO_HEIGHT,\n  SCREEN_WIDTH,\n  ASPECT_RATIO,\n  CARD_HEIGHT,\n} from "./constants";\nimport SocialSection from "./components/SocialSection";\n\nconst Post = ({ post, active }) => {\n  return (\n    <View style={{ height: CARD_HEIGHT }}>\n      <View style={styles.container}>\n        {post.video && (\n          <Video\n            source={{ uri: post.video }}\n            style={styles.video}\n            repeat\n            paused={!active}\n            controls={false}\n            resizeMode="cover"\n          />\n        )}\n        {post.photo && (\n          <Image\n            source={{ uri: post.photo }}\n            style={{\n              height: VIDEO_HEIGHT,\n              width: SCREEN_WIDTH,\n              aspectRatio: ASPECT_RATIO,\n            }}\n          />\n        )}\n      </View>\n      <SocialSection post={post} />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    height: VIDEO_HEIGHT,\n    width: "100%",\n  },\n  video: {\n    flex: 1,\n    objectFit: "cover",\n  },\n});\n\nexport default Post;\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="SocialSection.tsx"',children:'import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";\nimport { View, Text, StyleSheet } from "react-native";\nimport type { PostType } from "../posts";\n\ntype SocialSectionProps = {\n  post: PostType;\n};\n\nfunction SocialSection({ post }: SocialSectionProps) {\n  return (\n    <View style={styles.container}>\n      <View style={styles.row}>\n        <View style={styles.iconGroup}>\n          <View style={styles.icon}>\n            <FontAwesome6 name="heart" size={24} />\n            <Text style={styles.iconText}>{post.likes}</Text>\n          </View>\n          <View style={styles.icon}>\n            <FontAwesome6 name="comments" size={24} />\n            <Text style={styles.iconText}>{post.comments}</Text>\n          </View>\n          <FontAwesome6 name="paper-plane" size={24} />\n        </View>\n        <FontAwesome6 name="bookmark" size={24} />\n      </View>\n      <View style={styles.authorSection}>\n        <Text style={styles.author}>{post.author}</Text>\n        <Text style={styles.description}>{post.text}</Text>\n      </View>\n      <Text style={styles.date}>{post.date}</Text>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    margin: 12,\n  },\n  row: {\n    flexDirection: "row",\n    justifyContent: "space-between",\n  },\n  iconGroup: {\n    flexDirection: "row",\n    gap: 14,\n    alignItems: "center",\n  },\n  icon: {\n    flexDirection: "row",\n    alignItems: "center",\n    gap: 6,\n  },\n  iconText: {\n    fontWeight: "600",\n  },\n  description: {\n    fontWeight: "400",\n    color: "black",\n  },\n  date: { paddingTop: 4, color: "#5c5c5c" },\n  authorSection: {\n    paddingTop: 8,\n    flexDirection: "row",\n  },\n  author: {\n    fontWeight: "700",\n    paddingRight: 4,\n  },\n});\n\nexport default SocialSection;\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"build-the-feed-screen",children:["Build the ",(0,i.jsx)(n.code,{children:"Feed"})," screen"]}),"\n",(0,i.jsxs)(n.p,{children:["For simplicity, we'll use a plain ",(0,i.jsx)(n.code,{children:"ScrollView"})," without any virtualization. In a real app you'd most likely use ",(0,i.jsx)(n.code,{children:"FlatList"}),"/",(0,i.jsx)(n.code,{children:"FlashList"}),"/",(0,i.jsx)(n.code,{children:"LegendList"})," for better performance, but the goal of this tutorial is to demonstrate the idea behind the transition."]}),"\n",(0,i.jsx)(n.p,{children:"So let's create a simple scrollable list of posts:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="Feed.tsx"',children:'import { useState } from "react";\nimport { View, ScrollView, StyleSheet } from "react-native";\nimport { CARD_HEIGHT } from "./constants";\nimport { posts } from "./posts";\nimport Post from "./Post";\n\nexport default function Feed() {\n  const [index, setIndex] = useState(0);\n\n  const onScroll = (e) => {\n    const { y } = e.nativeEvent.contentOffset;\n    setIndex(Math.floor(y / (CARD_HEIGHT * 0.75)));\n  };\n\n  return (\n    <View style={styles.container}>\n      <ScrollView onScroll={onScroll}>\n        {posts.map((post, i) => (\n          <Post active={index === i} key={post.id} post={post} />\n        ))}\n      </ScrollView>\n    </View>\n  );\n}\n'})}),"\n",(0,i.jsx)(n.admonition,{title:"Play only one video at a time",type:"tip",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"index"})," tracks which post is currently visible so we only play one video at a time (the ",(0,i.jsx)(n.code,{children:"active"})," prop pauses off-screen videos to save resources)."]})}),"\n",(0,i.jsxs)(n.h3,{id:"build-the-reels-screen",children:["Build the ",(0,i.jsx)(n.code,{children:"Reels"})," screen"]}),"\n",(0,i.jsx)(n.p,{children:"The Reels screen is a vertical pager \u2014 each reel takes up the full screen and snaps into place:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="Reels.tsx"',children:'import { useState } from "react";\nimport { View, ScrollView, StyleSheet } from "react-native";\nimport { SCREEN_HEIGHT } from "./constants";\nimport { posts } from "./posts";\nimport FullScreenReel from "./components/FullScreenReel";\n\nexport default function Reels({ route }) {\n  const post = route.params.post;\n  const reels = posts.filter((p) => p.id !== post.id && p.video);\n  const [index, setIndex] = useState(0);\n\n  const onScroll = (e) => {\n    const { y } = e.nativeEvent.contentOffset;\n    setIndex(Math.round(y / SCREEN_HEIGHT));\n  };\n\n  return (\n    <View style={styles.container}>\n      <ScrollView\n        snapToInterval={SCREEN_HEIGHT}\n        decelerationRate="fast"\n        showsVerticalScrollIndicator={false}\n        onScroll={onScroll}\n        bounces={false}\n      >\n        <FullScreenReel post={post} active={index === 0} />\n        {reels.map((p, i) => (\n          <FullScreenReel key={p.id} post={p} active={index === i + 1} />\n        ))}\n      </ScrollView>\n    </View>\n  );\n}\n'})}),"\n",(0,i.jsx)(n.admonition,{title:"Default snapping behavior",type:"info",children:(0,i.jsxs)(n.p,{children:["We use ",(0,i.jsx)(n.code,{children:'decelerationRate="fast"'}),", ",(0,i.jsx)(n.code,{children:"snapToInterval={SCREEN_HEIGHT}"}),", and ",(0,i.jsx)(n.code,{children:"bounces={false}"})," to get a snapping effect without writing much code. The result may not feel exactly like the real Instagram app, but the goal of this tutorial is to focus on transitions, not on perfecting the snapping behavior."]})}),"\n",(0,i.jsx)(n.p,{children:"The tapped post is always first in the list, followed by other video posts."}),"\n",(0,i.jsx)(n.h2,{id:"step-2-add-navigation-without-shared-transitions",children:"Step 2: Add navigation (without shared transitions)"}),"\n",(0,i.jsxs)(n.p,{children:["Now let's wire up the screens with ",(0,i.jsx)(n.code,{children:"react-navigation"}),". The key decision here is the ",(0,i.jsx)(n.strong,{children:"presentation mode"})," for the Reels screen."]}),"\n",(0,i.jsxs)(n.h3,{id:"why-transparentmodal",children:["Why ",(0,i.jsx)(n.code,{children:"transparentModal"}),"?"]}),"\n",(0,i.jsxs)(n.p,{children:["We use ",(0,i.jsx)(n.code,{children:'presentation: "transparentModal"'})," for the Reels screen for two important reasons:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visible background during transitions"})," \u2014 When the video animates from its card position to full-screen, the feed is still visible behind it. A regular screen push would show a solid background, which isn't what we want."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Future gesture support"})," \u2014 If you later add a swipe-down-to-dismiss gesture, the user needs to see the feed screen underneath while dragging. A ",(0,i.jsx)(n.code,{children:"transparentModal"})," keeps the previous screen rendered and visible."]}),"\n"]}),"\n","\n",(0,i.jsx)("div",{className:"center video",children:(0,i.jsx)("img",{src:(0,a.Ay)("/img/instagram-transparent-modal.png"),style:{width:"35%"},alt:"Instagram modal"})}),"\n",(0,i.jsx)(n.h3,{id:"configure-the-navigator",children:"Configure the navigator"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="Navigation setup"',children:'// Screen options\nconst options = {\n  Feed: {\n    headerShown: false,\n  },\n  Reels: {\n    headerShown: false,\n    animation: "none", // we handle animations ourselves\n    presentation: "transparentModal", // keeps feed visible behind\n  },\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Setting ",(0,i.jsx)(n.code,{children:'animation: "none"'})," disables the default slide/fade transition because we'll drive the animation ourselves with Reanimated."]}),"\n",(0,i.jsxs)(n.h3,{id:"add-tap-handling-to-post",children:["Add tap handling to ",(0,i.jsx)(n.code,{children:"Post"})]}),"\n",(0,i.jsx)(n.p,{children:"Make each video post navigable:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="Post.tsx (updated)"',children:'import { useNavigation } from "@react-navigation/native";\nimport { TouchableWithoutFeedback } from "react-native";\n\nconst Post = ({ post, active }) => {\n  const navigation = useNavigation();\n\n  const onPress = () => {\n    if (post.photo) return; // only videos open Reels\n    navigation.navigate("Reels", { post });\n  };\n\n  return (\n    <View style={{ height: CARD_HEIGHT }}>\n      <TouchableWithoutFeedback onPress={onPress}>\n        <View style={styles.container}>\n          {/* old code that displays the video/image content */}\n        </View>\n      </TouchableWithoutFeedback>\n      <SocialSection post={post} />\n    </View>\n  );\n};\n'})}),"\n",(0,i.jsx)(r.A,{src:"/video/instagram-no-shared-transition.mov",width:"35%",autoPlay:!1,controls:!0,loop:!1}),"\n",(0,i.jsxs)(n.p,{children:["At this point you have a working app \u2014 tapping a video opens the ",(0,i.jsx)(n.code,{children:"Reels"})," screen, and calling ",(0,i.jsx)(n.code,{children:"navigation.goBack()"})," returns to ",(0,i.jsx)(n.code,{children:"Feed"}),". But there are two problems:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"there's no transition animation for the video;"}),"\n",(0,i.jsx)(n.li,{children:"the video starts playing from the beginning on the new screen."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Let's fix that!"}),"\n",(0,i.jsxs)(n.h2,{id:"step-3-add-the-teleport-infrastructure",children:["Step 3: Add the ",(0,i.jsx)(n.code,{children:"teleport"})," infrastructure"]}),"\n",(0,i.jsx)(n.p,{children:"This is where the magic happens. We need three things:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"A Zustand store"})," to coordinate the transition state between screens"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["A root-level ",(0,i.jsx)(n.code,{children:"PortalHost"})]})," to render content above all screens"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["A ",(0,i.jsx)(n.code,{children:"useMeasure"})," hook"]})," to get the tapped video's position on screen"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"the-transition-store",children:"The transition store"}),"\n",(0,i.jsx)(n.p,{children:"The store tracks everything needed to orchestrate the animation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="hooks/useTransition.ts"',children:'import {\n  makeMutable,\n  withSpring,\n  type SharedValue,\n} from "react-native-reanimated";\nimport { scheduleOnRN } from "react-native-worklets";\nimport { create } from "zustand";\n\ninterface Transition {\n  destination?: string; // where the portal renders: undefined | "overlay" | "reels"\n  id?: number; // which post is currently animating\n  y: number; // the tapped video\'s Y position on screen\n  progress: SharedValue<number>; // 0 = feed position, 1 = full-screen\n  setDestination: (destination?: string) => void;\n  setId: (id: number) => void;\n  goToReels: (y: number) => void;\n  goToFeed: (onFinish?: () => void) => void;\n}\n\nconst SPRING_CONFIG = { mass: 3, damping: 500, stiffness: 1000 };\n\nexport const useTransition = create<Transition>((set, get) => ({\n  destination: undefined,\n  id: undefined,\n  y: 0,\n  progress: makeMutable(0),\n  setDestination: (destination) => set({ destination }),\n  setId: (id) => set({ id }),\n  goToReels: (y) => {\n    set({ destination: "overlay", y });\n    const moveToReels = () => {\n      set({ destination: "reels" });\n    };\n    get().progress.set(\n      withSpring(1, SPRING_CONFIG, () => {\n        scheduleOnRN(moveToReels);\n      }),\n    );\n  },\n  goToFeed: (onFinish) => {\n    set({ destination: "overlay" });\n    const moveToFeed = () => {\n      set({ destination: undefined, y: 0 });\n      onFinish?.();\n    };\n    get().progress.set(\n      withSpring(0, SPRING_CONFIG, () => {\n        scheduleOnRN(moveToFeed);\n      }),\n    );\n  },\n}));\n'})}),"\n",(0,i.jsx)(n.p,{children:"Let's break down each field:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Field"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"destination"})}),(0,i.jsxs)(n.td,{children:["Controls where the ",(0,i.jsx)(n.code,{children:"<Portal>"})," renders. ",(0,i.jsx)(n.code,{children:"undefined"})," = in-place (feed), ",(0,i.jsx)(n.code,{children:'"overlay"'})," = floating above everything (during animation), ",(0,i.jsx)(n.code,{children:'"reels"'})," = inside the Reels screen."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"id"})}),(0,i.jsxs)(n.td,{children:["Which post is being transitioned. Only the matching ",(0,i.jsx)(n.code,{children:"<Post>"})," will teleport its content."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"y"})}),(0,i.jsxs)(n.td,{children:["The Y coordinate of the tapped video. Needed to animate ",(0,i.jsx)(n.code,{children:"translateY"})," so the video slides from its feed position to the top of the screen."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"progress"})}),(0,i.jsxs)(n.td,{children:["A Reanimated ",(0,i.jsx)(n.code,{children:"SharedValue"})," from ",(0,i.jsx)(n.code,{children:"0"})," to ",(0,i.jsx)(n.code,{children:"1"}),". Drives all animations: ",(0,i.jsx)(n.code,{children:"height"}),", ",(0,i.jsx)(n.code,{children:"translateY"}),", ",(0,i.jsx)(n.code,{children:"opacity"}),", etc. Using a shared value means animations run on the UI thread at 60fps and we can animate non-UI props, such as ",(0,i.jsx)(n.code,{children:"height"}),"."]})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"The two key methods orchestrate the transition:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"goToReels(y)"})})," \u2014 Sets destination to ",(0,i.jsx)(n.code,{children:'"overlay"'})," so the video escapes the feed's scroll container, then animates ",(0,i.jsx)(n.code,{children:"progress"})," from 0\u21921. When the spring finishes, switches destination to ",(0,i.jsx)(n.code,{children:'"reels"'})," so the video becomes part of the Reels screen."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"goToFeed(onFinish)"})})," \u2014 Reverses the process: destination back to ",(0,i.jsx)(n.code,{children:'"overlay"'}),", animate progress from 1\u21920, then clear everything and call ",(0,i.jsx)(n.code,{children:"onFinish"})," (which triggers ",(0,i.jsx)(n.code,{children:"navigation.goBack()"}),")."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{title:"Why Zustand?",type:"info",children:(0,i.jsxs)(n.p,{children:["We use Zustand instead of React Context because it gives us ",(0,i.jsx)(n.strong,{children:"granular subscriptions"}),". Each component selects only the slice of state it needs (",(0,i.jsx)(n.code,{children:"state.id === post.id"}),", ",(0,i.jsx)(n.code,{children:"state.progress"}),", etc.), so only the relevant components re-render. This is critical for performance during animations."]})}),"\n",(0,i.jsxs)(n.h3,{id:"set-up-the-root-portalhost",children:["Set up the root ",(0,i.jsx)(n.code,{children:"PortalHost"})]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:'"overlay"'})," ",(0,i.jsx)(n.code,{children:"PortalHost"})," must be placed at the root of your app, ",(0,i.jsx)(n.strong,{children:"after"})," the navigation container, so it renders on top of all screens:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="App.tsx"',children:'import { StyleSheet } from "react-native";\nimport { PortalHost, PortalProvider } from "react-native-teleport";\nimport { NavigationContainer } from "@react-navigation/native";\nimport { GestureHandlerRootView } from "react-native-gesture-handler";\n\nexport default function App() {\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <PortalProvider>\n        <NavigationContainer>\n          <RootStack />\n        </NavigationContainer>\n        {/* This host renders ABOVE all screens \u2014 perfect for the transition */}\n        <PortalHost name="overlay" style={StyleSheet.absoluteFillObject} />\n      </PortalProvider>\n    </GestureHandlerRootView>\n  );\n}\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"the-usemeasure-hook",children:["The ",(0,i.jsx)(n.code,{children:"useMeasure"})," hook"]}),"\n",(0,i.jsxs)(n.p,{children:["Before animating, we need to know ",(0,i.jsx)(n.strong,{children:"where"})," the tapped video is on screen. ",(0,i.jsx)(n.code,{children:"measureInWindow"})," gives us the absolute coordinates:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="hooks/useMeasure.ts"',children:'import { Platform, type View } from "react-native";\nimport { useSafeAreaInsets } from "react-native-safe-area-context";\n\nconst useMeasure = (viewRef: React.RefObject<View | null>) => {\n  const insets = useSafeAreaInsets();\n\n  return (callback: (x: number, y: number) => void) => {\n    viewRef.current?.measureInWindow((x, y) => {\n      // Android edge-to-edge mode can produce incorrect offsets\n      if (Platform.OS === "android") {\n        return callback(x, y + insets.top);\n      }\n      return callback(x, y);\n    });\n  };\n};\n\nexport default useMeasure;\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The measured ",(0,i.jsx)(n.code,{children:"y"})," value tells the animation system how far the video needs to translate vertically to reach the top of the screen."]}),"\n",(0,i.jsxs)(n.h2,{id:"step-4-add-the-portal-to-share-videos-between-screens",children:["Step 4: Add the ",(0,i.jsx)(n.code,{children:"<Portal>"})," to share videos between screens"]}),"\n",(0,i.jsxs)(n.p,{children:["Now we connect everything. This is where ",(0,i.jsx)(n.code,{children:"<Portal>"})," and ",(0,i.jsx)(n.code,{children:"<PortalHost>"})," bring the transition to life."]}),"\n",(0,i.jsxs)(n.h3,{id:"update-the-post-component",children:["Update the ",(0,i.jsx)(n.code,{children:"Post"})," component"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Post"})," component is the heart of the transition. It wraps the video in a ",(0,i.jsx)(n.code,{children:"<Portal>"})," whose destination changes based on the transition state:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="Post.tsx (final)"',children:'import { View, StyleSheet, Image } from "react-native";\nimport Video, { ViewType } from "react-native-video";\nimport { Portal } from "react-native-teleport";\nimport { TouchableWithoutFeedback } from "react-native-gesture-handler";\nimport Reanimated, {\n  interpolate,\n  useAnimatedStyle,\n} from "react-native-reanimated";\nimport { useNavigation } from "@react-navigation/native";\nimport { useRef } from "react";\nimport { useTransition } from "./hooks/useTransition";\nimport useMeasure from "../../hooks/useMeasure";\nimport { VIDEO_HEIGHT, SCREEN_HEIGHT, CARD_HEIGHT } from "./constants";\nimport SocialSection from "./components/SocialSection";\n\nconst Post = ({ post, active }) => {\n  const videoRef = useRef(null);\n  const navigation = useNavigation();\n  const measure = useMeasure(videoRef);\n\n  // Subscribe to only the state slices this post needs\n  const shouldMove = useTransition((state) => state.id === post.id);\n  const setId = useTransition((state) => state.setId);\n  const progress = useTransition((state) => state.progress);\n  const goToReels = useTransition((state) => state.goToReels);\n  const destination = useTransition((state) =>\n    shouldMove ? state.destination : undefined,\n  );\n  const y = useTransition((state) => (shouldMove ? state.y : 0));\n\n  const onPress = () => {\n    if (post.photo) return;\n    setId(post.id);\n    measure((_x, _y) => {\n      navigation.navigate("Reels", { post });\n      goToReels(_y);\n    });\n  };\n\n  // Animate height and position based on progress\n  const frame = useAnimatedStyle(\n    () => ({\n      height: shouldMove\n        ? interpolate(progress.value, [0, 1], [VIDEO_HEIGHT, SCREEN_HEIGHT])\n        : VIDEO_HEIGHT,\n      transform: [\n        {\n          translateY: shouldMove\n            ? interpolate(progress.value, [0, 1], [0, -y])\n            : 0,\n        },\n      ],\n    }),\n    [shouldMove, y],\n  );\n\n  return (\n    <View style={{ height: CARD_HEIGHT }}>\n      <TouchableWithoutFeedback onPress={onPress}>\n        <View ref={videoRef} style={styles.container}>\n          <Portal hostName={shouldMove ? destination : undefined}>\n            <Reanimated.View style={[{ width: "100%" }, frame]}>\n              {post.video && (\n                <Video\n                  source={{ uri: post.video }}\n                  style={[styles.video, { top: shouldMove ? y : 0 }]}\n                  repeat\n                  paused={!active}\n                  controls={false}\n                  resizeMode="cover"\n                  viewType={ViewType.TEXTURE}\n                />\n              )}\n              {post.photo && (\n                <Image source={{ uri: post.photo }} style={styles.photo} />\n              )}\n            </Reanimated.View>\n          </Portal>\n        </View>\n      </TouchableWithoutFeedback>\n      <SocialSection post={post} />\n    </View>\n  );\n};\n\nexport default Post;\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here's what happens step by step when the user taps a video:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"setId(post.id)"})})," \u2014 Marks this post as the one being transitioned. Only this post's ",(0,i.jsx)(n.code,{children:"shouldMove"})," becomes ",(0,i.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"measure()"})})," \u2014 Gets the video's current Y position on screen."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:'navigation.navigate("Reels", { post })'})})," \u2014 Opens the Reels screen (with ",(0,i.jsx)(n.code,{children:'animation: "none"'})," so nothing visible happens yet)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"goToReels(_y)"})})," \u2014 Sets ",(0,i.jsx)(n.code,{children:'destination: "overlay"'})," and starts the spring animation."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"<Portal>"})," now has ",(0,i.jsx)(n.code,{children:'hostName="overlay"'}),", so the video ",(0,i.jsx)(n.strong,{children:"teleports"})," from the feed to the root overlay."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"frame"})," animated style grows the video from ",(0,i.jsx)(n.code,{children:"VIDEO_HEIGHT"})," to ",(0,i.jsx)(n.code,{children:"SCREEN_HEIGHT"})," and translates it upward by ",(0,i.jsx)(n.code,{children:"y"})," pixels."]}),"\n",(0,i.jsxs)(n.li,{children:["When the spring finishes, ",(0,i.jsx)(n.code,{children:"destination"})," becomes ",(0,i.jsx)(n.code,{children:'"reels"'})," and the video teleports into the Reels screen's ",(0,i.jsx)(n.code,{children:"<PortalHost>"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"why-keep-the-container-height-fixed",children:"Why keep the container height fixed?"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"<View style={{ height: CARD_HEIGHT }}>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Notice that the outer ",(0,i.jsx)(n.code,{children:"<View>"})," always has a fixed ",(0,i.jsx)(n.code,{children:"CARD_HEIGHT"}),", even after the video teleports away. This is crucial \u2014 without it, the feed's ",(0,i.jsx)(n.code,{children:"ScrollView"}),' would reflow and jump when the video disappears, changing the scroll position and potentially switching which video is considered "active."']}),"\n",(0,i.jsxs)(n.h3,{id:"add-a-portalhost-in-the-reels-screen",children:["Add a ",(0,i.jsx)(n.code,{children:"PortalHost"})," in the ",(0,i.jsx)(n.code,{children:"Reels"})," screen"]}),"\n",(0,i.jsxs)(n.p,{children:["The first reel (the one the user tapped) needs a ",(0,i.jsx)(n.code,{children:"<PortalHost>"})," to receive the teleported video:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="components/FullScreenReel.tsx"',children:'import { View, StyleSheet } from "react-native";\nimport Video from "react-native-video";\nimport { Portal, PortalHost } from "react-native-teleport";\nimport {\n  SCREEN_HEIGHT,\n  SCREEN_WIDTH,\n  FLOATING_ELEMENTS_DESTINATION,\n} from "../constants";\nimport { useTransition } from "../hooks/useTransition";\nimport Reanimated, { useAnimatedStyle } from "react-native-reanimated";\n\nfunction FullScreenReel({ post, active, portal = false }) {\n  const progress = useTransition((state) => state.progress);\n  const destination = useTransition((state) => state.destination);\n\n  const icons = useAnimatedStyle(\n    () => ({\n      opacity: progress.value,\n    }),\n    [],\n  );\n\n  return (\n    <View style={styles.container}>\n      {portal ? (\n        // This host RECEIVES the teleported video from the feed\n        <PortalHost name="reels" style={styles.container} />\n      ) : (\n        // Other reels render their own video directly\n        <Video\n          source={{ uri: post.video }}\n          style={styles.video}\n          paused={!active}\n          resizeMode="cover"\n        />\n      )}\n      {/* Action buttons (like, comment, share) */}\n      <Portal\n        hostName={\n          portal && destination === "overlay"\n            ? FLOATING_ELEMENTS_DESTINATION\n            : undefined\n        }\n      >\n        <Reanimated.View style={[styles.icons, icons]}>\n          {/* ... like, comment, share buttons ... */}\n        </Reanimated.View>\n      </Portal>\n    </View>\n  );\n}\n\nexport default FullScreenReel;\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"portal"})," prop distinguishes the first reel (which receives the teleported video) from subsequent reels (which render their own inline video). Only the first ",(0,i.jsx)(n.code,{children:"FullScreenReel"})," renders a ",(0,i.jsx)(n.code,{children:'<PortalHost name="reels">'})," instead of a ",(0,i.jsx)(n.code,{children:"<Video>"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The action buttons (like, comment, share) are also portaled to the overlay during the transition so they fade in correctly on top of the animating video."}),"\n",(0,i.jsxs)(n.h3,{id:"update-the-feed-and-reels-screens-to-disable-scroll-during-transitions",children:["Update the ",(0,i.jsx)(n.code,{children:"Feed"})," and ",(0,i.jsx)(n.code,{children:"Reels"})," screens to disable scroll during transitions"]}),"\n",(0,i.jsx)(n.p,{children:"Both screens need to lock scrolling while the animation is in progress. Otherwise, the user could scroll the feed while the video is mid-flight:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="Feed.tsx (updated)"',children:'import Reanimated, { useAnimatedProps } from "react-native-reanimated";\nimport { useTransition } from "./hooks/useTransition";\n\nexport default function Feed() {\n  const progress = useTransition((state) => state.progress);\n\n  const animatedProps = useAnimatedProps(\n    () => ({\n      scrollEnabled: progress.value === 0, // only scroll when fully on feed\n    }),\n    [],\n  );\n\n  return (\n    <Reanimated.ScrollView animatedProps={animatedProps}>\n      {/* posts */}\n    </Reanimated.ScrollView>\n  );\n}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="Reels.tsx (updated)"',children:"const animatedProps = useAnimatedProps(\n  () => ({\n    scrollEnabled: progress.value === 1, // only scroll when fully on reels\n  }),\n  [],\n);\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"add-the-reelsheader-with-back-navigation",children:["Add the ",(0,i.jsx)(n.code,{children:"ReelsHeader"})," with back navigation"]}),"\n",(0,i.jsx)(n.p,{children:"Instagram uses a custom header in its app, and we'll build one too. The header animates alongside the video \u2014 it fades in and slides down from the video's original position:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="components/ReelsHeader.tsx"',children:'import {\n  View,\n  Text,\n  TouchableOpacity,\n  StyleSheet,\n  BackHandler,\n} from "react-native";\nimport { useSafeAreaInsets } from "react-native-safe-area-context";\nimport { useNavigation } from "@react-navigation/native";\nimport Reanimated, {\n  interpolate,\n  useAnimatedStyle,\n} from "react-native-reanimated";\nimport { Portal } from "react-native-teleport";\nimport { FLOATING_ELEMENTS_DESTINATION } from "../constants";\nimport { useTransition } from "../hooks/useTransition";\nimport { useCallback, useEffect } from "react";\n\nfunction ReelsHeader() {\n  const insets = useSafeAreaInsets();\n  const navigation = useNavigation();\n  const { goToFeed, progress, y } = useTransition();\n\n  const onGoBack = useCallback(() => {\n    goToFeed(navigation.goBack);\n  }, [goToFeed, navigation]);\n\n  // Handle Android hardware back button\n  useEffect(() => {\n    const subscription = BackHandler.addEventListener(\n      "hardwareBackPress",\n      () => {\n        onGoBack();\n        return true; // prevent default behavior\n      },\n    );\n    return () => subscription.remove();\n  }, [onGoBack]);\n\n  const style = useAnimatedStyle(\n    () => ({\n      opacity: progress.value,\n      transform: [{ translateY: interpolate(progress.value, [0, 1], [y, 0]) }],\n    }),\n    [y],\n  );\n\n  return (\n    <Portal hostName={FLOATING_ELEMENTS_DESTINATION} style={styles.container}>\n      <Reanimated.View style={[{ paddingTop: insets.top }, style]}>\n        <View style={styles.header}>\n          <Text style={styles.title}>Reels</Text>\n          <TouchableOpacity onPress={onGoBack}>\n            {/* back chevron icon */}\n          </TouchableOpacity>\n        </View>\n      </Reanimated.View>\n    </Portal>\n  );\n}\n\nexport default ReelsHeader;\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Notice how ",(0,i.jsx)(n.code,{children:"goToFeed"})," receives ",(0,i.jsx)(n.code,{children:"navigation.goBack"})," as the ",(0,i.jsx)(n.code,{children:"onFinish"})," callback. This means the actual navigation back only happens ",(0,i.jsx)(n.strong,{children:"after"})," the reverse animation completes, keeping everything perfectly synchronized."]}),"\n",(0,i.jsx)(n.p,{children:"And we need to add rendering of the header on our screen:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="Reels.tsx (updated)"',children:"function Reels({ route }: Props) {\n  return (\n    <View style={styles.container}>\n      {/* Old content, draw header on top of all elements */}\n      <ReelsHeader />\n    </View>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"platform-specific-rendering-for-floating-elements",children:"Platform-specific rendering for floating elements"}),"\n",(0,i.jsxs)(n.p,{children:["On iOS, ",(0,i.jsx)(n.code,{children:"transparentModal"})," presentation allows UI elements to render naturally on top of the modal. On Android, we need to portal them to the root overlay explicitly:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="constants.ts"',children:'import { Platform } from "react-native";\n\nexport const FLOATING_ELEMENTS_DESTINATION = Platform.select({\n  ios: undefined, // renders naturally above the modal\n  default: "root", // needs explicit portaling on Android\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"And now we can see how all pieces work together!"}),"\n",(0,i.jsx)(r.A,{src:"/video/instagram.mov",width:35}),"\n",(0,i.jsx)(n.h2,{id:"the-complete-transition-flow",children:"The complete transition flow"}),"\n",(0,i.jsx)(n.p,{children:"Here's the full lifecycle when a user taps a video and then goes back:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'1. User taps video in Feed\n   \u251c\u2500 setId(post.id)          \u2192 marks which post to animate\n   \u251c\u2500 measure()               \u2192 gets video\'s Y coordinate\n   \u251c\u2500 navigate("Reels")       \u2192 opens Reels (no visible animation)\n   \u2514\u2500 goToReels(y)            \u2192 starts the transition:\n       \u251c\u2500 destination = "overlay"  \u2192 video teleports to overlay\n       \u2514\u2500 progress: 0 \u2192 1         \u2192 height grows, translateY moves up\n\n2. Spring animation completes\n   \u2514\u2500 destination = "reels"   \u2192 video teleports into Reels PortalHost\n\n3. User is now on full-screen Reels\n   \u2514\u2500 Can scroll to other reels normally\n\n4. User taps back button\n   \u2514\u2500 goToFeed(goBack):\n       \u251c\u2500 destination = "overlay"  \u2192 video teleports back to overlay\n       \u2514\u2500 progress: 1 \u2192 0         \u2192 height shrinks, translateY moves down\n\n5. Reverse animation completes\n   \u251c\u2500 destination = undefined  \u2192 video returns to its feed position\n   \u251c\u2500 y = 0                    \u2192 reset\n   \u2514\u2500 navigation.goBack()     \u2192 Reels screen closes\n'})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"The key patterns used in this implementation:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"<Portal>"})})," dynamically changes its ",(0,i.jsx)(n.code,{children:"hostName"})," to move the video between the feed, an overlay, and the Reels screen \u2014 all without unmounting it."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"A fixed-height container"})," in the feed preserves scroll position while the video is teleported away."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"transparentModal"})," presentation"]})," keeps the feed visible during the transition and enables future gesture support."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["A Zustand store with Reanimated ",(0,i.jsx)(n.code,{children:"SharedValue"})]})," coordinates animation state across components while keeping everything on the UI thread."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"measureInWindow"})})," captures the video's screen position so the animation starts from exactly the right place."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"With these building blocks you can create fluid, Instagram-quality shared transitions in your own app. The same pattern works for any content \u2014 images, cards, avatars \u2014 anywhere you want seamless movement between screens."}),"\n",(0,i.jsxs)(n.p,{children:["If you'd like to see the complete working code, check out the ",(0,i.jsx)(n.a,{href:"https://github.com/kirillzyusko/react-native-teleport/tree/main/example/src/screens/Instagram",children:"example app"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}},9026:(e,n,t)=>{t.d(n,{A:()=>o});var s=t(6025),i=t(4848);function o({src:e,width:n=100,...t}){const o=(0,s.Ay)(e);return(0,i.jsx)("div",{className:"center video",children:(0,i.jsx)("video",{autoPlay:!0,loop:!0,muted:!0,playsInline:!0,height:"100%",src:o,width:`${n}%`,...t})})}}}]);