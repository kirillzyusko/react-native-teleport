# react-native-teleport

> Documentation for react-native-teleport. Package that allows to teleport views across your component tree for seamless transitions and powerful UI patterns.


## react-native-teleport


### pr-preview


#### pr-91

Teleport views across your component tree for seamless transitions and powerful UI patterns

- [Teleport](/index.md): Teleport views across your component tree for seamless transitions and powerful UI patterns
- [Search the documentation](/search.md)
- [Portal](/docs/api/components/portal.md): A component that moves its children to a different place in the view hierarchy.
- [PortalHost](/docs/api/components/portal-host.md): A component that acts as an anchor for the portals.
- [PortalProvider](/docs/api/components/portal-provider.md): A component that should wrap your app.
- [usePortal](/docs/api/hooks/use-portal.md): Hook that allows to manage portals.
- [üìö Components](/docs/category/-components.md): A set of JS components that helps you to render components outside of current component
- [üé£ Hooks](/docs/category/-hooks.md): React hooks provided by this library
- [API Reference](/docs/category/api-reference.md): API reference containing information about all public methods and their signatures
- [Guides](/docs/category/guides.md): Basic concepts and most useful topics to start quickly.
- [Recipes](/docs/category/recipes.md): Various tutorials to help you get the most out of the library.
- [Portal](/docs/guides/portal.md): Portal helps you to render a component in a different place in the view hierarchy.
- [Teleport](/docs/guides/teleport.md): Teleport helps you to re-use existing component and render it in a different part of tree without remounting and resetting the internal state.
- [Installation](/docs/installation.md): Guide dedicated to installation process
- [Intro](/docs/intro.md): Intro into portal and teleport concepts
- [Building Instagram-like Transitions](/docs/recipes/instagram-shared-transitions.md): Build Instagram-like shared transitions between a feed and full-screen reels viewer using react-native-teleport.
- [Jest testing guide](/docs/recipes/jest-testing-guide.md): A testing-guide showing how to write unit-tests using jest
- [Working with Modals](/docs/recipes/modals.md): Learn how modals work on iOS/Android and how to use Portal within modal screens.


---

# Full Documentation Content

[Skip to main content](#__docusaurus_skipToContent_fallback)

[![Teleport Logo](/react-native-teleport/pr-preview/pr-91/img/logo.svg)![Teleport Logo](/react-native-teleport/pr-preview/pr-91/img/logo.svg)](/react-native-teleport/pr-preview/pr-91/.md)

[**Teleport**](/react-native-teleport/pr-preview/pr-91/.md)[Guides](/react-native-teleport/pr-preview/pr-91/docs/intro.md)[API](/react-native-teleport/pr-preview/pr-91/docs/category/api-reference.md)[Blog](/react-native-teleport/pr-preview/pr-91/blog)[Next](/react-native-teleport/pr-preview/pr-91/docs/intro.md)

[Example App](https://github.com/kirillzyusko/react-native-teleport/tree/main/example)[GitHub](https://github.com/kirillzyusko/react-native-teleport)

Search

# Search the documentation

Type your search here

[](https://www.algolia.com/)

Docs

* [Guides](/react-native-teleport/pr-preview/pr-91/docs/installation.md)
* [Recipes](/react-native-teleport/pr-preview/pr-91/docs/category/recipes.md)
* [API](/react-native-teleport/pr-preview/pr-91/docs/category/api-reference.md)

Community

* [GitHub discussions](https://github.com/kirillzyusko/react-native-teleport/discussions)
* [X](https://x.com/ziusko)

More

* [Blog](/react-native-teleport/pr-preview/pr-91/blog)
* [GitHub](https://github.com/kirillzyusko/react-native-teleport)

Copyright ¬© 2026 Kirill Zyusko. Built with Docusaurus.


---

# Portal

`Portal` is a component that moves its children to a different place in the native view hierarchy and preserves the react tree structure.

View layout

When a `Portal` is teleported to a new host, it automatically recalculates its layout using the host‚Äôs dimensions and **fills the entire available space by default**.

You **do not need to specify any layout styles** (such as `flex: 1`) for this to work - the size is set internally when the portal is attached to the new host.

## Props[‚Äã](#props "Direct link to Props")

### `name`[‚Äã](#name "Direct link to name")

The name of the portal. It's used to identify the portal in the context of the portal host.

### `hostName`[‚Äã](#hostname "Direct link to hostname")

The `name` of the `PortalHost`. It's used to identify the host where the content should be rendered.

### `style`[‚Äã](#style "Direct link to style")

The style of the portal. Accepts [ViewStyle](https://reactnative.dev/docs/view#style) props.

### `children`[‚Äã](#children "Direct link to children")

The content that should be rendered in the portal.

## Example[‚Äã](#example "Direct link to Example")

```
import { useState } from "react";
import { View, StyleSheet, Button } from "react-native";
import { Portal } from "react-native-teleport";

export default function InstantRootExample() {
  const [shouldBeTeleported, setTeleported] = useState(true);

  return (
    <View style={styles.container}>
      {shouldBeTeleported && (
        <Portal hostName={"overlay"}>
          <View style={styles.box} testID="touchable" />
        </Portal>
      )}
      <Button
        title={shouldBeTeleported ? "Hide" : "Show"}
        onPress={() => setTeleported((t) => !t)}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  box: {
    width: 160,
    height: 160,
    marginVertical: 20,
    backgroundColor: "blue",
  },
});
```


---

# PortalHost

`PortalHost` is a component that acts as an anchor for the portals. You can define multiple portal hosts in your app and use them to render different portals. Each portal host has a unique name that you can use to identify a necessary one among the others.

View dimensions

`PortalHost` is just another view, so make sure that you set the correct dimensions for it. Otherwise, the portal ***may*** not be rendered correctly, especially if `Portal` relies on a flex layout and host has zero (i. e. `0x0`) dimensions.

## Props[‚Äã](#props "Direct link to Props")

### `name`[‚Äã](#name "Direct link to name")

The name of the portal host. It's used to identify the host by `<Portal />` component.

### `style`[‚Äã](#style "Direct link to style")

The style of the portal host. Accepts [ViewStyle](https://reactnative.dev/docs/view#style) props.

## Example[‚Äã](#example "Direct link to Example")

```
import { StyleSheet, View } from "react-native";
import { PortalHost, PortalProvider } from "react-native-teleport";
import {
  initialWindowMetrics,
  SafeAreaProvider,
} from "react-native-safe-area-context";
import RootStack from "./navigation";

export default function App() {
  return (
    <SafeAreaProvider initialMetrics={initialWindowMetrics}>
      <PortalProvider>
        <RootStack />
        <PortalHost style={StyleSheet.absoluteFillObject} name="overlay" />
      </PortalProvider>
    </SafeAreaProvider>
  );
}
```


---

# PortalProvider

Wrap your app with this component to use the portal API.

This component provides a context/registry for all Portals so that you can use imperative API, such as `usePortal` hook to manage Portals.

## Example[‚Äã](#example "Direct link to Example")

```
import { PortalProvider } from "react-native-teleport";

export default function App() {
  return (
    <PortalProvider>
      {/* your main application code goes here */}
    </PortalProvider>
  );
}
```


---

# usePortal

The `usePortal` hook allows you to manage portals in imperative way.

## Example[‚Äã](#example "Direct link to Example")

```
import { usePortal } from "react-native-teleport";

export default function App() {
  const { removePortal } = usePortal("root");

  return (
    <View style={{ flex: 1 }}>
      <Button title="Remove" onPress={() => removePortal("portal")} />
    </View>
  );
}
```

## Declaration[‚Äã](#declaration "Direct link to Declaration")

```
/**
 * @param hostName - `name` of the `<PortalHost />` component
 */
type usePortal = (hostName: string = "root") => {
  /**
   * Remove portal from host container. Subsequent re-renders will not restore portal,
   * but if you mount a new portal with the same name it will be shown (i. e. hook doesn't
   * prevent new portal from being added).
   * @param name - `name` of `<Portal />` component.
   */
  removePortal: (name: string) => void;
};
```


---

## [üìÑÔ∏è<!-- --> <!-- -->PortalProvider](/react-native-teleport/pr-preview/pr-91/docs/api/components/portal-provider.md)

[A component that should wrap your app.](/react-native-teleport/pr-preview/pr-91/docs/api/components/portal-provider.md)


---

## [üìÑÔ∏è<!-- --> <!-- -->usePortal](/react-native-teleport/pr-preview/pr-91/docs/api/hooks/use-portal.md)

[Hook that allows to manage portals.](/react-native-teleport/pr-preview/pr-91/docs/api/hooks/use-portal.md)


---

## [üóÉÔ∏è<!-- --> <!-- -->üìö Components](/react-native-teleport/pr-preview/pr-91/docs/category/-components.md)

[3 items](/react-native-teleport/pr-preview/pr-91/docs/category/-components.md)


---

## [üìÑÔ∏è<!-- --> <!-- -->Portal](/react-native-teleport/pr-preview/pr-91/docs/guides/portal.md)

[Portal helps you to render a component in a different place in the view hierarchy.](/react-native-teleport/pr-preview/pr-91/docs/guides/portal.md)


---

## [üìÑÔ∏è<!-- --> <!-- -->Jest testing guide](/react-native-teleport/pr-preview/pr-91/docs/recipes/jest-testing-guide.md)

[A testing-guide showing how to write unit-tests using jest](/react-native-teleport/pr-preview/pr-91/docs/recipes/jest-testing-guide.md)


---

# Portal

The **Portal** API allows you to render a component in a different place in the view hierarchy. This is useful when you need a view to visually ‚Äúbreak out‚Äù of its parent container (for example: modals, toasts, floating UI, popovers).

![Portal helps to render a new view in a different container](/react-native-teleport/pr-preview/pr-91/assets/images/portal-2b20b94e26669e61959d937697ed6dde.png)

Unlike simple `zIndex` tricks, Portals actually move the native view to another container, which guarantees correct behavior across different platforms, stacking contexts, and clipping boundaries.

## Why use Portal?[‚Äã](#why-use-portal "Direct link to Why use Portal?")

* Escape parent clipping: Portals are not limited by `overflow: hidden` or scroll containers.
* Native-level stacking: Works even where `zIndex` fails.
* Cross-platform: Consistent on iOS, Android and web.
* Dynamic UI: Great for modals, floating buttons, dropdowns, tooltips, and system-like overlays.

## Example[‚Äã](#example "Direct link to Example")

```
import { useState } from "react";
import { View, StyleSheet, Button } from "react-native";
import { Portal } from "react-native-teleport";

export default function InstantRootExample() {
  const [shouldBeTeleported, setTeleported] = useState(true);

  return (
    <View style={styles.container}>
      {shouldBeTeleported && (
        <Portal hostName={"overlay"}>
          <View style={styles.box} testID="touchable" />
        </Portal>
      )}
      <Button
        title={shouldBeTeleported ? "Hide" : "Show"}
        onPress={() => setTeleported((t) => !t)}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  box: {
    width: 160,
    height: 160,
    marginVertical: 20,
    backgroundColor: "blue",
  },
});
```

## Best practices[‚Äã](#best-practices "Direct link to Best practices")

* Always declare at least one `<PortalHost />` near your app root.
* Use host names if you need multiple layers (e.g., modal, toast, tooltip).

Teleportation

‚ö° **Tip**: If you need to move an **existing** view (without unmounting/remounting), check out [Teleport](/react-native-teleport/pr-preview/pr-91/docs/guides/teleport.md) guide.


---

# Teleport

The **Teleport** concept allows you to move an **existing view** to a different place in the hierarchy **without unmounting or remounting** it. This means the component keeps its internal state (animations, scroll position, video progress, etc.) even after being visually moved. This pattern is also known as **re-parenting**.

![Teleport helps to move existing view between different layers without losing state](/react-native-teleport/pr-preview/pr-91/assets/images/teleport-65785a9f1211bc6992db0cca2993d621.png)

## Example[‚Äã](#example "Direct link to Example")

App.tsx

```
import { StyleSheet, View } from "react-native";
import { PortalHost, PortalProvider } from "react-native-teleport";
import {
  initialWindowMetrics,
  SafeAreaProvider,
} from "react-native-safe-area-context";
import { NavigationContainer } from "@react-navigation/native";
import RootStack from "./navigation";
import { GestureHandlerRootView } from "react-native-gesture-handler";

export default function App() {
  return (
    <SafeAreaProvider initialMetrics={initialWindowMetrics}>
      <GestureHandlerRootView style={styles.container}>
        <PortalProvider>
          <>{/* Deeply nested <Teleport /> component goes here */}</>
          <PortalHost style={StyleSheet.absoluteFillObject} name="overlay" />
        </PortalProvider>
      </GestureHandlerRootView>
    </SafeAreaProvider>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});
```

Teleport.tsx

```
import LottieView from "lottie-react-native";
import { useRef, useState } from "react";
import {
  View,
  Text,
  ScrollView,
  TouchableWithoutFeedback,
  StyleSheet,
  Animated,
  useAnimatedValue,
  Easing,
  Pressable,
} from "react-native";
import { BlurView } from "@react-native-community/blur";
import { Portal } from "react-native-teleport";

const messages = [
  { text: "Hello, how are you", sender: true },
  { text: "Hello, not too bad! You?", sender: false },
  { text: "I'm fine, thanks", sender: true },
  { text: "What is your plan for evening today?", sender: true },
  { text: "I'm not sure yet... Any ideas?", sender: false },
  { text: "Sure, let's go for a walk?", sender: true },
];

const Message = ({ sender, text }) => {
  return (
    <View
      style={{
        flexDirection: "row",
        width: "100%",
        justifyContent: sender ? "flex-end" : "flex-start",
      }}
    >
      <Text
        style={{
          opacity: 1,
          color: "black",
          padding: 10,
          backgroundColor: sender ? "#38f269" : "#38c7f2",
          margin: 10,
          borderRadius: 10,
        }}
      >
        {text}
      </Text>
    </View>
  );
};

export default function Messenger() {
  const viewRef = useRef<View | null>(null);
  const opacity = useRef(new Animated.Value(0)).current;
  const [teleport, setTeleported] = useState(false);
  const [style, setStyle] = useState(null);

  const handleClick = () => {
    Animated.timing(opacity, {
      toValue: 1,
      duration: 250,
      easing: Easing.inOut(Easing.ease),
      useNativeDriver: true,
    }).start();
    viewRef.current?.measureInWindow((x, y) => {
      setTeleported(true);
      setStyle({
        paddingTop: y,
      });
    });
  };

  return (
    <View style={{ flex: 1 }}>
      <ScrollView>
        {messages.map((item) => (
          <Message key={item.text} {...item} />
        ))}
        <View
          ref={viewRef}
          style={{
            width: "100%",
            justifyContent: "flex-start",
            flexDirection: "row",
          }}
        >
          <Portal hostName={teleport ? "overlay" : undefined}>
            <Pressable onPress={handleClick} style={style ?? {}}>
              <LottieView
                source={require("../../assets/lottie/bear.json")}
                style={[{ width: 200, height: 200 }]}
                autoPlay
                loop
              />
            </Pressable>
          </Portal>
        </View>
      </ScrollView>
      <Animated.View
        style={[StyleSheet.absoluteFillObject, { opacity: opacity }]}
        pointerEvents="none"
      >
        <BlurView
          style={StyleSheet.absoluteFillObject}
          pointerEvents="none"
          blurType="light"
          blurAmount={16}
        />
      </Animated.View>
    </View>
  );
}
```

## Why use Teleport?[‚Äã](#why-use-teleport "Direct link to Why use Teleport?")

* **Preserve state**: No unmount/remount ‚Äî animations, scroll, video, inputs remain intact.
* **Build advanced transitions**: Implement shared-element‚Äìstyle transitions between screens.
* **Escape container limits**: Move a view to an overlay while keeping its internal logic alive.
* **Power complex UI**: Great for photo galleries, YouTube-like mini players, context menu transitions, app tours, off-screen pre-rendering, etc.


---

# Installation

## Adding a library to the project[‚Äã](#adding-a-library-to-the-project "Direct link to Adding a library to the project")

New Architecture only

This library is compatible **only** with the **new (Fabric)** architecture.

Install the `react-native-teleport` package in your React Native project.

* YARN
* NPM
* EXPO

```
yarn add react-native-teleport
```

```
npm install react-native-teleport --save
```

```
npx expo install react-native-teleport
```

Only Expo Dev client compatible

This library has native code, so it **does not work** with *Expo Go* but it's fully compatible with [custom dev client](https://docs.expo.dev/development/getting-started/).

### Linking[‚Äã](#linking "Direct link to Linking")

This package supports [autolinking](https://github.com/react-native-community/cli/blob/master/docs/autolinking.md).

Pods update

After adding the package don't forget to **re-install** `pods` and **re-assemble** `android` and `ios` applications, since this library contains native code.

If you still experience issues like **package doesn't seem to be linked** try performing a fresh build to clear any outdated cache.

## Adding provider[‚Äã](#adding-provider "Direct link to Adding provider")

In order to use it you'll need to wrap your app with `PortalProvider` component.

```
import { PortalProvider } from "react-native-teleport";

export default function App() {
  return (
    <PortalProvider>
      {/* your main application code goes here */}
    </PortalProvider>
  );
}
```

Congratulations! üéâ You've just finished installation process. Go to the [next section](/react-native-teleport/pr-preview/pr-91/docs/guides/portal.md) to get more insights of what you can do using this library. üòé


---

# Intro

## What is the portal?[‚Äã](#what-is-the-portal "Direct link to What is the portal?")

A **Portal** lets you render a component somewhere else in the UI tree, while keeping it logically inside its parent.<br /><!-- -->Typical use cases include **modals**, **tooltips**, **popovers**, and other overlays where the visual position differs from the React tree position.

On the web this is done with [`createPortal`](https://react.dev/reference/react-dom/createPortal), but React Native has no built-in solution ([issue #36273](https://github.com/facebook/react-native/issues/36273)).

## Existing solutions (and their limits)[‚Äã](#existing-solutions-and-their-limits "Direct link to Existing solutions (and their limits)")

Community libraries like [@gorhom/portal](https://github.com/gorhom/react-native-portal) or [react-gateway](https://github.com/cloudflare/react-gateway) emulate portals in **JavaScript**. They work, but:

‚ùå Components are **re-parented in JS**, not in the actual native view tree.<br /><!-- -->‚ùå This can break or block access to **React Context** values (theme, navigation, i18n, etc.).<br /><!-- -->‚ùå Rendering is still bound to the JS layer, which can limit **performance** and **platform-native behaviors**.

## Introducing `react-native-teleport`[‚Äã](#introducing-react-native-teleport "Direct link to introducing-react-native-teleport")

This library brings **true native portals** to React Native:

‚úÖ The component stays in the **original React tree** ‚Üí contexts & state are preserved.<br /><!-- -->‚úÖ The view is physically moved in the **native view hierarchy** ‚Üí correct layout, z-order & performance.<br /><!-- -->‚úÖ Works across **iOS, Android, and Web**.<br /><!-- -->‚úÖ Supports not only portals but also **re-parenting (teleport)**: move an existing view without unmounting it.

You can think of it as:

> **"Teleport your view in native space, without breaking React logic."**

## Comparison[‚Äã](#comparison "Direct link to Comparison")

|                                                         | `react-native-teleport` | `@gorhom/portal` |
| ------------------------------------------------------- | ----------------------- | ---------------- |
| Render local component in a different place in the tree | ‚úÖ                      | ‚úÖ               |
| Support multiple hosts/portals                          | ‚úÖ                      | ‚úÖ               |
| Native implementation                                   | ‚úÖ                      | ‚ùå               |
| Keeps React tree continuity                             | ‚úÖ                      | ‚ùå               |
| Preserves React context                                 | ‚úÖ                      | ‚ùå               |
| Move views without losing state (teleport)              | ‚úÖ                      | ‚ùå               |
| Mirroring 1                                             | üü† 2                    | ‚ùå               |

> 1 create a live copy of a view elsewhere in the tree (similar to a real-time snapshot).

> 2 Is planned to be added in the future

***

## Next steps[‚Äã](#next-steps "Direct link to Next steps")

Ready to get started? üöÄ Head over to the [Installation](/react-native-teleport/pr-preview/pr-91/docs/installation.md) guide.


---

# Building Instagram-like Transitions

In this guide we'll recreate the transition Instagram uses when you tap a video in your feed and it smoothly expands into a full-screen Reels viewer. When you go back, the video shrinks back into its original position ‚Äî all without interrupting playback.

We'll use iOS transition reference and will replicate it to iOS, Android and web, so that navigation on all 3 platforms delivers the same exceptional experience.

<!-- -->

[](/react-native-teleport/pr-preview/pr-91/video/instagram.mov)

## How it works ‚Äî the big picture[‚Äã](#how-it-works--the-big-picture "Direct link to How it works ‚Äî the big picture")

The core idea is simple: **there is only one video instance, and we move it between screens**.

Traditional navigation would unmount the feed screen's video and mount a brand-new one on the Reels screen. That causes a visible flash, resets playback, and makes a smooth transition impossible.

With `react-native-teleport`, we take a different approach:

1. The video lives inside a `<Portal>` in the Feed screen.
2. When the user taps, we **teleport** the video to an overlay layer that sits above all screens.
3. While in the overlay, we animate the video from its card size to full-screen.
4. Once the animation completes, we teleport the video into a `<PortalHost>` inside the Reels screen.
5. Going back reverses the process: teleport to overlay ‚Üí animate back to card size ‚Üí return to feed.

Because the video is **re-parented** (moved in the native view hierarchy) rather than unmounted/remounted, playback is never interrupted, animations stay alive, and the transition feels seamless.

```
Feed (in-place) ‚îÄ‚îÄtap‚îÄ‚îÄ‚ñ∂ Overlay (animating) ‚îÄ‚îÄdone‚îÄ‚îÄ‚ñ∂ Reels (in-place)
                                                              ‚îÇ
                         Overlay (animating) ‚óÄ‚îÄ‚îÄback‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
Feed (in-place) ‚óÄ‚îÄ‚îÄdone‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Prerequisites[‚Äã](#prerequisites "Direct link to Prerequisites")

This guide assumes you have a React Native project with the following libraries installed:

* [`react-native-teleport`](/react-native-teleport/pr-preview/pr-91/docs/installation.md) ‚Äî the star of the show
* [`@react-navigation/native-stack`](https://reactnavigation.org/docs/native-stack-navigator/) ‚Äî for navigation (but you can use **any** navigation library)
* [`react-native-reanimated`](https://docs.swmansion.com/react-native-reanimated/) ‚Äî for smooth animations
* [`react-native-video`](https://docs.thewidlarzgroup.com/react-native-video) ‚Äî for video playback (but you can use other libraries)
* [`zustand`](https://zustand.docs.pmnd.rs/) ‚Äî for lightweight state management

## Step 1: Build the basic layout[‚Äã](#step-1-build-the-basic-layout "Direct link to Step 1: Build the basic layout")

Let's start with a static feed ‚Äî no navigation, no transitions, just layout.

### Define constants[‚Äã](#define-constants "Direct link to Define constants")

First, define the dimensions we'll use throughout:

constants.ts

```
import { Dimensions } from "react-native";

export const SCREEN_HEIGHT = Dimensions.get("screen").height;
export const SCREEN_WIDTH = Math.min(Dimensions.get("screen").width, 540);
export const ASPECT_RATIO = 3 / 4;
export const VIDEO_HEIGHT = SCREEN_WIDTH / ASPECT_RATIO;
export const CARD_HEIGHT = VIDEO_HEIGHT + 100; // video + social section below
```

### Define post data[‚Äã](#define-post-data "Direct link to Define post data")

Create a simple data model for posts. Each post can have either a video or a photo:

posts.ts

```
export type PostType = {
  id: number;
  author: string;
  text: string;
  likes: number;
  comments: number;
  video?: ReturnType<typeof require>;
  photo?: string;
  date: string;
  sent: number;
};

export const posts: PostType[] = [
  {
    id: 1,
    author: "kirillzyusko",
    text: "Magic forest",
    likes: 126,
    comments: 12,
    sent: 31,
    video: require("./videos/forest.mp4"),
    date: "29 October",
  },
  // ... more posts
];
```

### Build the Post component[‚Äã](#build-the-post-component "Direct link to Build the Post component")

Each post card shows a video (or image) with a social section underneath:

Post.tsx

```
import { View, StyleSheet, Image } from "react-native";
import Video from "react-native-video";
import { VIDEO_HEIGHT, SCREEN_WIDTH, ASPECT_RATIO, CARD_HEIGHT } from "./constants";
import SocialSection from "./components/SocialSection";

const Post = ({ post, active }) => {
  return (
    <View style={{ height: CARD_HEIGHT }}>
      <View style={styles.container}>
        {post.video && (
          <Video
            source={{ uri: post.video }}
            style={styles.video}
            repeat
            paused={!active}
            controls={false}
            resizeMode="cover"
          />
        )}
        {post.photo && (
          <Image
            source={{ uri: post.photo }}
            style={{
              height: VIDEO_HEIGHT,
              width: SCREEN_WIDTH,
              aspectRatio: ASPECT_RATIO,
            }}
          />
        )}
      </View>
      <SocialSection post={post} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    height: VIDEO_HEIGHT,
    width: "100%",
  },
  video: {
    flex: 1,
    objectFit: "cover",
  },
});

export default Post;
```

SocialSection.tsx

```
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import { View, Text, StyleSheet } from "react-native";
import type { PostType } from "../posts";

type SocialSectionProps = {
  post: PostType;
};

function SocialSection({ post }: SocialSectionProps) {
  return (
    <View style={styles.container}>
      <View style={styles.row}>
        <View style={styles.iconGroup}>
          <View style={styles.icon}>
            <FontAwesome6 name="heart" size={24} />
            <Text style={styles.iconText}>{post.likes}</Text>
          </View>
          <View style={styles.icon}>
            <FontAwesome6 name="comments" size={24} />
            <Text style={styles.iconText}>{post.comments}</Text>
          </View>
          <FontAwesome6 name="paper-plane" size={24} />
        </View>
        <FontAwesome6 name="bookmark" size={24} />
      </View>
      <View style={styles.authorSection}>
        <Text style={styles.author}>{post.author}</Text>
        <Text style={styles.description}>{post.text}</Text>
      </View>
      <Text style={styles.date}>{post.date}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    margin: 12,
  },
  row: {
    flexDirection: "row",
    justifyContent: "space-between",
  },
  iconGroup: {
    flexDirection: "row",
    gap: 14,
    alignItems: "center",
  },
  icon: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  iconText: {
    fontWeight: "600",
  },
  description: {
    fontWeight: "400",
    color: "black",
  },
  date: { paddingTop: 4, color: "#5c5c5c" },
  authorSection: {
    paddingTop: 8,
    flexDirection: "row",
  },
  author: {
    fontWeight: "700",
    paddingRight: 4,
  },
});

export default SocialSection;
```

### Build the Feed screen[‚Äã](#build-the-feed-screen "Direct link to Build the Feed screen")

For a simplicity purposes we'll use a plain `ScrollView` without any virtualizations. In real world apps most likely you'll be using `FlatList`/`FlashList`/`LegendList` for delivering best performance, but the goal of this tutorial is to show the idea that stays behind the transition.

So let's create a simple scrollable list of posts:

Feed.tsx

```
import { useState } from "react";
import { View, ScrollView, StyleSheet } from "react-native";
import { CARD_HEIGHT } from "./constants";
import { posts } from "./posts";
import Post from "./Post";

export default function Feed() {
  const [index, setIndex] = useState(0);

  const onScroll = (e) => {
    const { y } = e.nativeEvent.contentOffset;
    setIndex(Math.floor(y / (CARD_HEIGHT * 0.75)));
  };

  return (
    <View style={styles.container}>
      <ScrollView onScroll={onScroll}>
        {posts.map((post, i) => (
          <Post active={index === i} key={post.id} post={post} />
        ))}
      </ScrollView>
    </View>
  );
}
```

Play only one video at a time

The `index` tracks which post is currently visible so we only play one video at a time (the `active` prop pauses off-screen videos to save resources).

### Build the Reels screen[‚Äã](#build-the-reels-screen "Direct link to Build the Reels screen")

The Reels screen is a vertical pager ‚Äî each reel takes up the full screen and snaps into place:

Reels.tsx

```
import { useState } from "react";
import { View, ScrollView, StyleSheet } from "react-native";
import { SCREEN_HEIGHT } from "./constants";
import { posts } from "./posts";
import FullScreenReel from "./components/FullScreenReel";

export default function Reels({ route }) {
  const post = route.params.post;
  const reels = posts.filter((p) => p.id !== post.id && p.video);
  const [index, setIndex] = useState(0);

  const onScroll = (e) => {
    const { y } = e.nativeEvent.contentOffset;
    setIndex(Math.round(y / SCREEN_HEIGHT));
  };

  return (
    <View style={styles.container}>
      <ScrollView
        snapToInterval={SCREEN_HEIGHT}
        decelerationRate="fast"
        showsVerticalScrollIndicator={false}
        onScroll={onScroll}
        bounces={false}
      >
        <FullScreenReel post={post} active={index === 0} />
        {reels.map((p, i) => (
          <FullScreenReel key={p.id} post={p} active={index === i + 1} />
        ))}
      </ScrollView>
    </View>
  );
}
```

Default snapping behavior

We are using `decelerationRate="fast"` , `snapToInterval={SCREEN_HEIGHT}` and `bounces={false}` to achieve an effect of snapping without writing too much code. It offers default behavior and may not feel like a real Instagram app, but the goal of this tutorial is focusing on transitions and not on snapping.

The tapped post is always first in the list, followed by other video posts.

## Step 2: Add navigation (without shared transitions)[‚Äã](#step-2-add-navigation-without-shared-transitions "Direct link to Step 2: Add navigation (without shared transitions)")

Now let's wire up the screens with `react-navigation`. The key decision here is the **presentation mode** for the Reels screen.

### Why `transparentModal`?[‚Äã](#why-transparentmodal "Direct link to why-transparentmodal")

We use `presentation: "transparentModal"` for the Reels screen for two important reasons:

1. **Visible background during transitions** ‚Äî When the video animates from its card position to full-screen, the feed is still visible behind it. A regular screen push would show a solid background (which is not desired in out case).
2. **Future gesture support** ‚Äî If you later add a swipe-down-to-dismiss gesture, the user needs to see the feed screen underneath while dragging. A `transparentModal` keeps the previous screen rendered and visible.

<!-- -->

![Instagram modal](/react-native-teleport/pr-preview/pr-91/img/instagram-transparent-modal.png)

TODO: re-capture image

### Configure the navigator[‚Äã](#configure-the-navigator "Direct link to Configure the navigator")

Navigation setup

```
// Screen options
const options = {
  Feed: {
    headerShown: false,
  },
  Reels: {
    headerShown: false,
    animation: "none",                // we handle animations ourselves
    presentation: "transparentModal", // keeps feed visible behind
  },
};
```

Setting `animation: "none"` disables the default slide/fade transition because we'll drive the animation ourselves with Reanimated.

### Add tap handling to Post[‚Äã](#add-tap-handling-to-post "Direct link to Add tap handling to Post")

Make each video post navigable:

Post.tsx (updated)

```
import { useNavigation } from "@react-navigation/native";
import { TouchableWithoutFeedback } from "react-native";

const Post = ({ post, active }) => {
  const navigation = useNavigation();

  const onPress = () => {
    if (post.photo) return; // only videos open Reels
    navigation.navigate("Reels", { post });
  };

  return (
    <View style={{ height: CARD_HEIGHT }}>
      <TouchableWithoutFeedback onPress={onPress}>
        <View style={styles.container}>
          {/* video/image content */}
        </View>
      </TouchableWithoutFeedback>
      <SocialSection post={post} />
    </View>
  );
};
```

[](/react-native-teleport/pr-preview/pr-91/video/instagram-no-shared-transition.mov)

TODO: back button

TODO: re-capture video

TODO: make sure no additional imports required

At this point you have a working app ‚Äî tapping a video opens Reels, pressing back returns to Feed, but:

* there's no transition animation for video;
* video starts to play from the beginning on a new screen.

Let's fix that!

## Step 3: Add the teleport infrastructure[‚Äã](#step-3-add-the-teleport-infrastructure "Direct link to Step 3: Add the teleport infrastructure")

This is where the magic happens. We need three things:

1. **A Zustand store** to coordinate the transition state between screens
2. **A root-level `PortalHost`** to render content above all screens
3. **A `useMeasure` hook** to get the tapped video's position on screen

### The transition store[‚Äã](#the-transition-store "Direct link to The transition store")

The store tracks everything needed to orchestrate the animation:

hooks/useTransition.ts

```
import { makeMutable, withSpring, type SharedValue } from "react-native-reanimated";
import { scheduleOnRN } from "react-native-worklets";
import { create } from "zustand";

interface Transition {
  destination?: string;           // where the portal renders: undefined | "overlay" | "reels"
  id?: number;                    // which post is currently animating
  y: number;                      // the tapped video's Y position on screen
  progress: SharedValue<number>;  // 0 = feed position, 1 = full-screen
  setDestination: (destination?: string) => void;
  setId: (id: number) => void;
  goToReels: (y: number) => void;
  goToFeed: (onFinish?: () => void) => void;
}

const SPRING_CONFIG = { mass: 3, damping: 500, stiffness: 1000 };

export const useTransition = create<Transition>((set, get) => ({
  destination: undefined,
  id: undefined,
  y: 0,
  progress: makeMutable(0),
  setDestination: (destination) => set({ destination }),
  setId: (id) => set({ id }),
  goToReels: (y) => {
    set({ destination: "overlay", y });
    get().progress.set(
      withSpring(1, SPRING_CONFIG, () => {
        scheduleOnRN(() => set({ destination: "reels" }));
      }),
    );
  },
  goToFeed: (onFinish) => {
    set({ destination: "overlay" });
    get().progress.set(
      withSpring(0, SPRING_CONFIG, () => {
        scheduleOnRN(() => {
          set({ destination: undefined, y: 0 });
          onFinish?.();
        });
      }),
    );
  },
}));
```

Let's break down each field:

| Field         | Purpose                                                                                                                                                                         |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `destination` | Controls where the `<Portal>` renders. `undefined` = in-place (feed), `"overlay"` = floating above everything (during animation), `"reels"` = inside the Reels screen.          |
| `id`          | Which post is being transitioned. Only the matching `<Post>` will teleport its content.                                                                                         |
| `y`           | The Y coordinate of the tapped video. Needed to animate `translateY` so the video slides from its feed position to the top of the screen.                                       |
| `progress`    | A Reanimated `SharedValue` from `0` to `1`. Drives all animations: `height`, `translateY`, `opacity`, etc. Using a shared value means animations run on the UI thread at 60fps. |

The two key methods orchestrate the transition:

* **`goToReels(y)`** ‚Äî Sets destination to `"overlay"` so the video escapes the feed's scroll container, then animates `progress` from 0‚Üí1. When the spring finishes, switches destination to `"reels"` so the video becomes part of the Reels screen.
* **`goToFeed(onFinish)`** ‚Äî Reverses the process: destination back to `"overlay"`, animate progress from 1‚Üí0, then clear everything and call `onFinish` (which triggers `navigation.goBack()`).

Why Zustand?

We use Zustand instead of React Context because it gives us **granular subscriptions**. Each component selects only the slice of state it needs (`state.id === post.id`, `state.progress`, etc.), so only the relevant components re-render. This is critical for performance during animations.

### Set up the root PortalHost[‚Äã](#set-up-the-root-portalhost "Direct link to Set up the root PortalHost")

The `"overlay"` `PortalHost` must be placed at the root of your app, **after** the navigation container, so it renders on top of all screens:

App.tsx

```
import { StyleSheet } from "react-native";
import { PortalHost, PortalProvider } from "react-native-teleport";
import { NavigationContainer } from "@react-navigation/native";
import { GestureHandlerRootView } from "react-native-gesture-handler";

export default function App() {
  return (
    <GestureHandlerRootView style={styles.container}>
      <PortalProvider>
        <NavigationContainer>
          <RootStack />
        </NavigationContainer>
        {/* This host renders ABOVE all screens ‚Äî perfect for the transition */}
        <PortalHost name="overlay" style={StyleSheet.absoluteFillObject} />
      </PortalProvider>
    </GestureHandlerRootView>
  );
}
```

### The useMeasure hook[‚Äã](#the-usemeasure-hook "Direct link to The useMeasure hook")

Before animating, we need to know **where** the tapped video is on screen. `measureInWindow` gives us the absolute coordinates:

hooks/useMeasure.ts

```
import { Platform, type View } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";

const useMeasure = (viewRef: React.RefObject<View | null>) => {
  const insets = useSafeAreaInsets();

  return (callback: (x: number, y: number) => void) => {
    viewRef.current?.measureInWindow((x, y) => {
      // Android edge-to-edge mode can produce incorrect offsets
      if (Platform.OS === "android") {
        return callback(x, y + insets.top);
      }
      return callback(x, y);
    });
  };
};
```

The measured `y` value tells the animation system how far the video needs to translate vertically to reach the top of the screen.

## Step 4: Add the `<Portal>` to share videos between screens[‚Äã](#step-4-add-the-portal-to-share-videos-between-screens "Direct link to step-4-add-the-portal-to-share-videos-between-screens")

Now we connect everything. This is where `<Portal>` and `<PortalHost>` bring the transition to life.

### Update the Post component[‚Äã](#update-the-post-component "Direct link to Update the Post component")

The `Post` component is the heart of the transition. It wraps the video in a `<Portal>` whose destination changes based on the transition state:

Post.tsx (final)

```
import { View, StyleSheet, Image } from "react-native";
import Video, { ViewType } from "react-native-video";
import { Portal } from "react-native-teleport";
import { TouchableWithoutFeedback } from "react-native-gesture-handler";
import Reanimated, { interpolate, useAnimatedStyle } from "react-native-reanimated";
import { useNavigation } from "@react-navigation/native";
import { useRef } from "react";
import { useTransition } from "./hooks/useTransition";
import useMeasure from "../../hooks/useMeasure";
import { VIDEO_HEIGHT, SCREEN_HEIGHT, CARD_HEIGHT } from "./constants";
import SocialSection from "./components/SocialSection";

const Post = ({ post, active }) => {
  const videoRef = useRef(null);
  const navigation = useNavigation();
  const measure = useMeasure(videoRef);

  // Subscribe to only the state slices this post needs
  const shouldMove = useTransition((state) => state.id === post.id);
  const setId = useTransition((state) => state.setId);
  const progress = useTransition((state) => state.progress);
  const goToReels = useTransition((state) => state.goToReels);
  const destination = useTransition((state) =>
    shouldMove ? state.destination : undefined,
  );
  const y = useTransition((state) => (shouldMove ? state.y : 0));

  const onPress = () => {
    if (post.photo) return;
    setId(post.id);
    measure((_x, _y) => {
      navigation.navigate("Reels", { post });
      goToReels(_y);
    });
  };

  // Animate height and position based on progress
  const frame = useAnimatedStyle(
    () => ({
      height: shouldMove
        ? interpolate(progress.value, [0, 1], [VIDEO_HEIGHT, SCREEN_HEIGHT])
        : VIDEO_HEIGHT,
      transform: [
        {
          translateY: shouldMove
            ? interpolate(progress.value, [0, 1], [0, -y])
            : 0,
        },
      ],
    }),
    [shouldMove, y],
  );

  return (
    <View style={{ height: CARD_HEIGHT }}>
      <TouchableWithoutFeedback onPress={onPress}>
        <View ref={videoRef} style={styles.container}>
          <Portal hostName={shouldMove ? destination : undefined}>
            <Reanimated.View style={[{ width: "100%" }, frame]}>
              {post.video && (
                <Video
                  source={{ uri: post.video }}
                  style={[styles.video, { top: shouldMove ? y : 0 }]}
                  repeat
                  paused={!active}
                  controls={false}
                  resizeMode="cover"
                  viewType={ViewType.TEXTURE}
                />
              )}
              {post.photo && (
                <Image source={{ uri: post.photo }} style={styles.photo} />
              )}
            </Reanimated.View>
          </Portal>
        </View>
      </TouchableWithoutFeedback>
      <SocialSection post={post} />
    </View>
  );
};
```

Here's what happens step by step when the user taps a video:

1. **`setId(post.id)`** ‚Äî Marks this post as the one being transitioned. Only this post's `shouldMove` becomes `true`.
2. **`measure()`** ‚Äî Gets the video's current Y position on screen.
3. **`navigation.navigate("Reels", { post })`** ‚Äî Opens the Reels screen (with `animation: "none"` so nothing visible happens yet).
4. **`goToReels(_y)`** ‚Äî Sets `destination: "overlay"` and starts the spring animation.
5. The `<Portal>` now has `hostName="overlay"`, so the video **teleports** from the feed to the root overlay.
6. The `frame` animated style grows the video from `VIDEO_HEIGHT` to `SCREEN_HEIGHT` and translates it upward by `y` pixels.
7. When the spring finishes, `destination` becomes `"reels"` and the video teleports into the Reels screen's `<PortalHost>`.

### Why keep the container height fixed?[‚Äã](#why-keep-the-container-height-fixed "Direct link to Why keep the container height fixed?")

```
<View style={{ height: CARD_HEIGHT }}>
```

Notice that the outer `<View>` always has a fixed `CARD_HEIGHT`, even after the video teleports away. This is crucial ‚Äî without it, the feed's `ScrollView` would reflow and jump when the video disappears, changing the scroll position and potentially switching which video is considered "active."

### Add a PortalHost in the Reels screen[‚Äã](#add-a-portalhost-in-the-reels-screen "Direct link to Add a PortalHost in the Reels screen")

The first reel (the one the user tapped) needs a `<PortalHost>` to receive the teleported video:

components/FullScreenReel.tsx

```
import { View, StyleSheet } from "react-native";
import Video from "react-native-video";
import { Portal, PortalHost } from "react-native-teleport";
import { SCREEN_HEIGHT, SCREEN_WIDTH, FLOATING_ELEMENTS_DESTINATION } from "../constants";
import { useTransition } from "../hooks/useTransition";
import Reanimated, { useAnimatedStyle } from "react-native-reanimated";

function FullScreenReel({ post, active, portal = false }) {
  const progress = useTransition((state) => state.progress);
  const destination = useTransition((state) => state.destination);

  const icons = useAnimatedStyle(() => ({
    opacity: progress.value,
  }), []);

  return (
    <View style={styles.container}>
      {portal ? (
        // This host RECEIVES the teleported video from the feed
        <PortalHost name="reels" style={styles.container} />
      ) : (
        // Other reels render their own video directly
        <Video
          source={{ uri: post.video }}
          style={styles.video}
          paused={!active}
          resizeMode="cover"
        />
      )}
      {/* Action buttons (like, comment, share) */}
      <Portal
        hostName={
          portal && destination === "overlay"
            ? FLOATING_ELEMENTS_DESTINATION
            : undefined
        }
      >
        <Reanimated.View style={[styles.icons, icons]}>
          {/* ... like, comment, share buttons ... */}
        </Reanimated.View>
      </Portal>
    </View>
  );
}
```

The `portal` prop distinguishes the first reel (which receives the teleported video) from subsequent reels (which render their own inline video). Only the first `FullScreenReel` renders a `<PortalHost name="reels">` instead of a `<Video>`.

The action buttons (like, comment, share) are also portaled to the overlay during the transition so they fade in correctly on top of the animating video.

### Update the Feed and Reels screens to disable scroll during transitions[‚Äã](#update-the-feed-and-reels-screens-to-disable-scroll-during-transitions "Direct link to Update the Feed and Reels screens to disable scroll during transitions")

Both screens need to lock scrolling while the animation is in progress. Otherwise, the user could scroll the feed while the video is mid-flight:

Feed.tsx (updated)

```
import Reanimated, { useAnimatedProps } from "react-native-reanimated";
import { useTransition } from "./hooks/useTransition";

export default function Feed() {
  const progress = useTransition((state) => state.progress);

  const animatedProps = useAnimatedProps(() => ({
    scrollEnabled: progress.value === 0, // only scroll when fully on feed
  }), []);

  return (
    <Reanimated.ScrollView animatedProps={animatedProps}>
      {/* posts */}
    </Reanimated.ScrollView>
  );
}
```

Reels.tsx (updated)

```
const animatedProps = useAnimatedProps(() => ({
  scrollEnabled: progress.value === 1, // only scroll when fully on reels
}), []);
```

### Add the ReelsHeader with back navigation[‚Äã](#add-the-reelsheader-with-back-navigation "Direct link to Add the ReelsHeader with back navigation")

The header animates alongside the video ‚Äî it fades in and slides down from the video's original position:

components/ReelsHeader.tsx

```
import { View, Text, TouchableOpacity, StyleSheet, BackHandler } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useNavigation } from "@react-navigation/native";
import Reanimated, { interpolate, useAnimatedStyle } from "react-native-reanimated";
import { Portal } from "react-native-teleport";
import { FLOATING_ELEMENTS_DESTINATION } from "../constants";
import { useTransition } from "../hooks/useTransition";
import { useCallback, useEffect } from "react";

function ReelsHeader() {
  const insets = useSafeAreaInsets();
  const navigation = useNavigation();
  const { goToFeed, progress, y } = useTransition();

  const onGoBack = useCallback(() => {
    goToFeed(navigation.goBack);
  }, [goToFeed, navigation]);

  // Handle Android hardware back button
  useEffect(() => {
    const subscription = BackHandler.addEventListener("hardwareBackPress", () => {
      onGoBack();
      return true; // prevent default behavior
    });
    return () => subscription.remove();
  }, [onGoBack]);

  const style = useAnimatedStyle(() => ({
    opacity: progress.value,
    transform: [
      { translateY: interpolate(progress.value, [0, 1], [y, 0]) },
    ],
  }), [y]);

  return (
    <Portal hostName={FLOATING_ELEMENTS_DESTINATION} style={styles.container}>
      <Reanimated.View style={[{ paddingTop: insets.top }, style]}>
        <View style={styles.header}>
          <Text style={styles.title}>Reels</Text>
          <TouchableOpacity onPress={onGoBack}>
            {/* back chevron icon */}
          </TouchableOpacity>
        </View>
      </Reanimated.View>
    </Portal>
  );
}
```

Notice how `goToFeed` receives `navigation.goBack` as the `onFinish` callback. This means the actual navigation back only happens **after** the reverse animation completes, keeping everything perfectly synchronized.

### Platform-specific rendering for floating elements[‚Äã](#platform-specific-rendering-for-floating-elements "Direct link to Platform-specific rendering for floating elements")

On iOS, `transparentModal` presentation allows UI elements to render naturally on top of the modal. On Android, we need to portal them to the root overlay explicitly:

constants.ts

```
import { Platform } from "react-native";

export const FLOATING_ELEMENTS_DESTINATION = Platform.select({
  ios: undefined,     // renders naturally above the modal
  default: "root",    // needs explicit portaling on Android
});
```

## The complete transition flow[‚Äã](#the-complete-transition-flow "Direct link to The complete transition flow")

Here's the full lifecycle when a user taps a video and then goes back:

```
1. User taps video in Feed
   ‚îú‚îÄ setId(post.id)          ‚Üí marks which post to animate
   ‚îú‚îÄ measure()               ‚Üí gets video's Y coordinate
   ‚îú‚îÄ navigate("Reels")       ‚Üí opens Reels (no visible animation)
   ‚îî‚îÄ goToReels(y)            ‚Üí starts the transition:
       ‚îú‚îÄ destination = "overlay"  ‚Üí video teleports to overlay
       ‚îî‚îÄ progress: 0 ‚Üí 1         ‚Üí height grows, translateY moves up

2. Spring animation completes
   ‚îî‚îÄ destination = "reels"   ‚Üí video teleports into Reels PortalHost

3. User is now on full-screen Reels
   ‚îî‚îÄ Can scroll to other reels normally

4. User taps back button
   ‚îî‚îÄ goToFeed(goBack):
       ‚îú‚îÄ destination = "overlay"  ‚Üí video teleports back to overlay
       ‚îî‚îÄ progress: 1 ‚Üí 0         ‚Üí height shrinks, translateY moves down

5. Reverse animation completes
   ‚îú‚îÄ destination = undefined  ‚Üí video returns to its feed position
   ‚îú‚îÄ y = 0                    ‚Üí reset
   ‚îî‚îÄ navigation.goBack()     ‚Üí Reels screen closes
```

## Summary[‚Äã](#summary "Direct link to Summary")

The key patterns used in this implementation:

* **`<Portal>`** dynamically changes its `hostName` to move the video between the feed, an overlay, and the Reels screen ‚Äî all without unmounting it.
* **A fixed-height container** in the feed preserves scroll position while the video is teleported away.
* **`transparentModal` presentation** keeps the feed visible during the transition and enables future gesture support.
* **A Zustand store with Reanimated `SharedValue`** coordinates animation state across components while keeping everything on the UI thread.
* **`measureInWindow`** captures the video's screen position so the animation starts from exactly the right place.

With these building blocks you can create fluid, Instagram-quality shared transitions in your own app. The same pattern works for any content ‚Äî images, cards, avatars ‚Äî anywhere you want seamless movement between screens.


---

# Jest testing guide

## Setting up a mock[‚Äã](#setting-up-a-mock "Direct link to Setting up a mock")

This library includes a built in mock for Jest. To use it, add the following code to the [jest setup](https://jestjs.io/docs/configuration#setupfiles-array) file:

```
jest.mock("react-native-teleport", () => require("react-native-teleport/jest"));
```

## Test case example[‚Äã](#test-case-example "Direct link to Test case example")

Once you've set up mock - you can write your first test üòä. A sample of test case is shown below. For more test cases please see [this](https://github.com/kirillzyusko/react-native-teleport/tree/main/example/__tests__) link.

```
import { render, screen } from "@testing-library/react-native";

import { View } from "react-native";

import { PortalProvider, PortalHost, Portal } from "react-native-teleport";

function TestComponent() {
  return (
    <PortalProvider>
      <PortalHost name="app" />
      <View>
        <Portal hostName="app" name="modal">
          <View />
        </Portal>
      </View>
    </PortalProvider>
  );
}

describe("portal rendering", () => {
  it("should render without errors", () => {
    render(<TestComponent />);

    expect(screen.toJSON()).toMatchSnapshot();
  });
});
```


---

# Working with Modals

When using `react-native-teleport` with modal screens (e.g., screens presented with `presentation: 'transparentModal'` or `presentation: 'modal'`) or the `Modal` component, you may notice that teleported components don't appear at all. This happens because **modals create a separate native window hierarchy**, and your `PortalHost` is attached to a **different window**.

## How Modals work?[‚Äã](#how-modals-work "Direct link to How Modals work?")

### iOS[‚Äã](#ios "Direct link to iOS")

On iOS, React Native's modal implementation uses `UIWindow`/`UITransitionView` to present content. When a modal screen is shown, React Native creates a new `UIWindow`/`UITransitionView` that sits above your app's main window in the z-order. This ensures that modal content always appears on top of other app content.

<!-- -->

![iOS Modal Windows Diagram. The modal UITransitionView sits above the main UITransitionView, and the teleported content is rendered behind the modal.](/react-native-teleport/pr-preview/pr-91/assets/images/ios-adb18e2a599c269a7b047504c4c7efcf.png)

Since the `PortalHost` is in the main window and the `Portal` is trying to render from the modal window, the teleported content ends up being rendered **behind** the modal - invisible to the user.

### Android[‚Äã](#android "Direct link to Android")

Android works similarly. When a modal is presented, React Native uses a `Dialog` or `DialogFragment` which creates a new window layer (`Window`) that floats above the main activity's content. The view hierarchy inside the dialog is separate from the main activity's view tree.

<!-- -->

![Android Modal Windows Diagram. The DialogRootViewGroup sits above the main ReactSurfaceView, and the teleported content is rendered behind the modal.](/react-native-teleport/pr-preview/pr-91/assets/images/android-31d18cc723515cad057b047c5a95680a.png)

## The Solution[‚Äã](#the-solution "Direct link to The Solution")

The solution is straightforward: **add a `PortalHost` inside your modal screen**. This creates a portal destination within the modal's window hierarchy, allowing teleported content to render correctly.

```
import { StyleSheet, View } from "react-native";
import { PortalHost } from "react-native-teleport";

function ModalScreen() {
  return (
    <View style={styles.container}>
      {/* Your modal content */}
      <YourModalContent />

      {/* Add a PortalHost for this modal's window */}
      <PortalHost style={StyleSheet.absoluteFillObject} name="modal-overlay" />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});
```

## Best Practices[‚Äã](#best-practices "Direct link to Best Practices")

### Use Unique Host Names[‚Äã](#use-unique-host-names "Direct link to Use Unique Host Names")

When you have multiple modals or screens with their own `PortalHost`, use unique names to avoid conflicts:

```
// In ModalA
<PortalHost name="modal-a-overlay" />

// In ModalB
<PortalHost name="modal-b-overlay" />
```

### Create a Reusable Modal Wrapper[‚Äã](#create-a-reusable-modal-wrapper "Direct link to Create a Reusable Modal Wrapper")

To avoid repetition, create a reusable component that includes the `PortalHost`:

components/ModalContainer.tsx

```
import { StyleSheet, View, ViewProps } from "react-native";
import { PortalHost } from "react-native-teleport";

interface ModalContainerProps extends ViewProps {
  portalHostName: string;
  children: React.ReactNode;
}

export function ModalContainer({
  portalHostName,
  children,
  style,
  ...props
}: ModalContainerProps) {
  return (
    <View style={[styles.container, style]} {...props}>
      {children}
      <PortalHost style={StyleSheet.absoluteFillObject} name={portalHostName} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});
```

Usage:

```
import { ModalContainer } from "./components/ModalContainer";

function MyModal() {
  return (
    <ModalContainer portalHostName="my-modal-overlay">
      <Text>Modal content here</Text>
      <Portal hostName="my-modal-overlay">
        <TooltipComponent />
      </Portal>
    </ModalContainer>
  );
}
```

Remember

The key insight is that **modals create separate native windows**. Your `PortalHost` must be in the same window hierarchy as the `Portal` that targets it.


---

[Skip to main content](#__docusaurus_skipToContent_fallback)

[![Teleport Logo](/react-native-teleport/pr-preview/pr-91/img/logo.svg)![Teleport Logo](/react-native-teleport/pr-preview/pr-91/img/logo.svg)](/react-native-teleport/pr-preview/pr-91/.md)

[**Teleport**](/react-native-teleport/pr-preview/pr-91/.md)[Guides](/react-native-teleport/pr-preview/pr-91/docs/intro.md)[API](/react-native-teleport/pr-preview/pr-91/docs/category/api-reference.md)[Blog](/react-native-teleport/pr-preview/pr-91/blog)[Next](/react-native-teleport/pr-preview/pr-91/docs/intro.md)

[Example App](https://github.com/kirillzyusko/react-native-teleport/tree/main/example)[GitHub](https://github.com/kirillzyusko/react-native-teleport)

Search

# Teleport

Missing native portal implementation for react-native

[Get started](/react-native-teleport/pr-preview/pr-91/docs/intro.md)

Docs

* [Guides](/react-native-teleport/pr-preview/pr-91/docs/installation.md)
* [Recipes](/react-native-teleport/pr-preview/pr-91/docs/category/recipes.md)
* [API](/react-native-teleport/pr-preview/pr-91/docs/category/api-reference.md)

Community

* [GitHub discussions](https://github.com/kirillzyusko/react-native-teleport/discussions)
* [X](https://x.com/ziusko)

More

* [Blog](/react-native-teleport/pr-preview/pr-91/blog)
* [GitHub](https://github.com/kirillzyusko/react-native-teleport)

Copyright ¬© 2026 Kirill Zyusko. Built with Docusaurus.


---

