"use strict";(self.webpackChunkreact_native_teleport_docs=self.webpackChunkreact_native_teleport_docs||[]).push([[679],{263:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/teleport-65785a9f1211bc6992db0cca2993d621.png"},6685:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"guides/teleport","title":"Teleport","description":"Teleport helps you to re-use existing component and render it in a different part of tree without remounting and resetting the internal state.","source":"@site/docs/guides/teleport.mdx","sourceDirName":"guides","slug":"/guides/teleport","permalink":"/react-native-teleport/pr-preview/pr-19/docs/guides/teleport","draft":false,"unlisted":false,"editUrl":"https://github.com/kirillzyusko/react-native-teleport/tree/main/docs/docs/guides/teleport.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"description":"Teleport helps you to re-use existing component and render it in a different part of tree without remounting and resetting the internal state.","keywords":["react-native-teleport","react-native teleport","react-native portal","re-parent","reparent","reparentable","teleport","teleportation","portal"]},"sidebar":"tutorialSidebar","previous":{"title":"Portal","permalink":"/react-native-teleport/pr-preview/pr-19/docs/guides/portal"},"next":{"title":"Recipes","permalink":"/react-native-teleport/pr-preview/pr-19/docs/category/recipes"}}');var i=n(4848),o=n(8453);const s={sidebar_position:2,description:"Teleport helps you to re-use existing component and render it in a different part of tree without remounting and resetting the internal state.",keywords:["react-native-teleport","react-native teleport","react-native portal","re-parent","reparent","reparentable","teleport","teleportation","portal"]},a="Teleport",l={},c=[{value:"Example",id:"example",level:2},{value:"Why use Teleport?",id:"why-use-teleport",level:2}];function p(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"teleport",children:"Teleport"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"Teleport"})," concept allows you to move an ",(0,i.jsx)(t.strong,{children:"existing view"})," to a different place in the hierarchy ",(0,i.jsx)(t.strong,{children:"without unmounting or remounting"})," it.\nThis means the component keeps its internal state (animations, scroll position, video progress, etc.) even after being visually moved. This pattern is also known as ",(0,i.jsx)(t.strong,{children:"re-parenting"}),"."]}),"\n",(0,i.jsx)("div",{className:"lottie",children:(0,i.jsx)("img",{src:n(263).A,alt:"Teleport helps to move existing view between different layers without losing state"})}),"\n",(0,i.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="App.tsx"',children:'import { StyleSheet, View } from "react-native";\nimport { PortalHost, PortalProvider } from "react-native-teleport";\nimport {\n  initialWindowMetrics,\n  SafeAreaProvider,\n} from "react-native-safe-area-context";\nimport { NavigationContainer } from "@react-navigation/native";\nimport RootStack from "./navigation";\nimport { GestureHandlerRootView } from "react-native-gesture-handler";\n\nexport default function App() {\n  return (\n    <SafeAreaProvider initialMetrics={initialWindowMetrics}>\n      <GestureHandlerRootView style={styles.container}>\n        <PortalProvider>\n          {/* Deeply nested <Teleport /> component goes here */}\n          <View style={StyleSheet.absoluteFillObject} pointerEvents="box-none">\n            <PortalHost name="overlay" />\n          </View>\n        </PortalProvider>\n      </GestureHandlerRootView>\n    </SafeAreaProvider>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n});\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="Teleport.tsx"',children:'import LottieView from "lottie-react-native";\nimport { useRef, useState } from "react";\nimport {\n  View,\n  Text,\n  ScrollView,\n  TouchableWithoutFeedback,\n  StyleSheet,\n  Animated,\n  useAnimatedValue,\n  Easing,\n  Pressable,\n} from "react-native";\nimport { BlurView } from "@react-native-community/blur";\nimport { Portal } from "react-native-teleport";\n\nconst messages = [\n  { text: "Hello, how are you", sender: true },\n  { text: "Hello, not too bad! You?", sender: false },\n  { text: "I\'m fine, thanks", sender: true },\n  { text: "What is your plan for evening today?", sender: true },\n  { text: "I\'m not sure yet... Any ideas?", sender: false },\n  { text: "Sure, let\'s go for a walk?", sender: true },\n];\n\nconst Message = ({ sender, text }) => {\n  return (\n    <View\n      style={{\n        flexDirection: "row",\n        width: "100%",\n        justifyContent: sender ? "flex-end" : "flex-start",\n      }}\n    >\n      <Text\n        style={{\n          opacity: 1,\n          color: "black",\n          padding: 10,\n          backgroundColor: sender ? "#38f269" : "#38c7f2",\n          margin: 10,\n          borderRadius: 10,\n        }}\n      >\n        {text}\n      </Text>\n    </View>\n  );\n};\n\nexport default function Messenger() {\n  const viewRef = useRef<View | null>(null);\n  const opacity = useRef(new Animated.Value(0)).current;\n  const [teleport, setTeleported] = useState(false);\n  const [style, setStyle] = useState(null);\n\n  const handleClick = () => {\n    Animated.timing(opacity, {\n      toValue: 1,\n      duration: 250,\n      easing: Easing.inOut(Easing.ease),\n      useNativeDriver: true,\n    }).start();\n    viewRef.current?.measureInWindow((x, y) => {\n      setTeleported(true);\n      setStyle({\n        paddingTop: y,\n      });\n    });\n  };\n\n  return (\n    <View style={{ flex: 1 }}>\n      <ScrollView>\n        {messages.map((item) => (\n          <Message key={item.text} {...item} />\n        ))}\n        <View\n          ref={viewRef}\n          style={{\n            width: "100%",\n            justifyContent: "flex-start",\n            flexDirection: "row",\n          }}\n        >\n          <Portal hostName={teleport ? "overlay" : undefined}>\n            <Pressable onPress={handleClick} style={style ?? {}}>\n              <LottieView\n                source={require("../../assets/lottie/bear.json")}\n                style={[{ width: 200, height: 200 }]}\n                autoPlay\n                loop\n              />\n            </Pressable>\n          </Portal>\n        </View>\n      </ScrollView>\n      <Animated.View\n        style={[StyleSheet.absoluteFillObject, { opacity: opacity }]}\n        pointerEvents="none"\n      >\n        <BlurView\n          style={StyleSheet.absoluteFillObject}\n          pointerEvents="none"\n          blurType="light"\n          blurAmount={16}\n        />\n      </Animated.View>\n    </View>\n  );\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"why-use-teleport",children:"Why use Teleport?"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Preserve state"}),": No unmount/remount \u2014 animations, scroll, video, inputs remain intact."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Build advanced transitions"}),": Implement shared-element\u2013style transitions between screens."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Escape container limits"}),": Move a view to an overlay while keeping its internal logic alive."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Power complex UI"}),": Great for photo galleries, YouTube-like mini players, context menu transitions, app tours, off-screen pre-rendering, etc."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var r=n(6540);const i={},o=r.createContext(i);function s(e){const t=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);