diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ExoPlayerView.kt b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ExoPlayerView.kt
index bb945fe..0625cad 100644
--- a/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ExoPlayerView.kt
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ExoPlayerView.kt
@@ -3,11 +3,17 @@ package com.brentvatne.exoplayer
 import android.content.Context
 import android.graphics.Color
 import android.graphics.drawable.GradientDrawable
+import android.os.Build
 import android.util.AttributeSet
+import android.view.Surface
+import android.view.SurfaceControl
+import android.view.SurfaceHolder
+import android.view.SurfaceView
 import android.view.View
 import android.view.View.MeasureSpec
 import android.widget.FrameLayout
 import android.widget.TextView
+import androidx.annotation.RequiresApi
 import androidx.media3.common.Player
 import androidx.media3.common.Timeline
 import androidx.media3.common.util.UnstableApi
@@ -24,6 +30,13 @@ class ExoPlayerView @JvmOverloads constructor(context: Context, attrs: Attribute
 
     private var localStyle = SubtitleStyle()
     private var pendingResizeMode: Int? = null
+    
+    // SurfaceControl support for seamless re-parenting (Android 10+)
+    private var surfaceControlVideoView: SurfaceView? = null
+    private var videoSurfaceControl: SurfaceControl? = null
+    private var videoSurface: Surface? = null
+    private var useSurfaceControl = Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q
+    
     private val liveBadge: TextView = TextView(context).apply {
         text = "LIVE"
         setTextColor(Color.WHITE)
@@ -61,6 +74,103 @@ class ExoPlayerView @JvmOverloads constructor(context: Context, attrs: Attribute
         val liveBadgeLayoutParams = LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT)
         liveBadgeLayoutParams.setMargins(16, 16, 16, 16)
         addView(liveBadge, liveBadgeLayoutParams)
+        
+        // Initialize SurfaceControl if available
+        if (useSurfaceControl && Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+            initializeSurfaceControl()
+        }
+    }
+
+    /**
+     * Initialize SurfaceControl for seamless video re-parenting (Android 10+).
+     * Creates a persistent video surface that can be moved between views without interruption.
+     */
+    @RequiresApi(Build.VERSION_CODES.Q)
+    private fun initializeSurfaceControl() {
+        // Create SurfaceView to hold the video surface
+        surfaceControlVideoView = SurfaceView(context).apply {
+            layoutParams = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)
+            
+            holder.addCallback(object : SurfaceHolder.Callback {
+                override fun surfaceCreated(holder: SurfaceHolder) {
+                    ensureVideoSurfaceControl()
+                    reparentVideoSurface()
+                }
+                
+                override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {
+                    updateVideoSurfaceBufferSize(width, height)
+                }
+                
+                override fun surfaceDestroyed(holder: SurfaceHolder) {
+                    // Don't destroy the video surface, just hide it
+                    hideVideoSurface()
+                }
+            })
+        }
+        
+        // Add the SurfaceView to PlayerView's video surface container
+        // This will be positioned behind the controller overlay
+        val contentFrame = playerView.findViewById<FrameLayout>(androidx.media3.ui.R.id.exo_content_frame)
+        if (contentFrame != null) {
+            contentFrame.addView(surfaceControlVideoView, 0)
+        }
+    }
+    
+    /**
+     * Creates the persistent video SurfaceControl and Surface if not already created.
+     */
+    @RequiresApi(Build.VERSION_CODES.Q)
+    private fun ensureVideoSurfaceControl() {
+        if (videoSurfaceControl == null) {
+            videoSurfaceControl = SurfaceControl.Builder()
+                .setName("RNVideo-SurfaceControl")
+                .setBufferSize(0, 0)
+                .build()
+            
+            videoSurface = Surface(videoSurfaceControl)
+        }
+    }
+    
+    /**
+     * Re-parents the video surface to the current SurfaceView.
+     */
+    @RequiresApi(Build.VERSION_CODES.Q)
+    private fun reparentVideoSurface() {
+        val surfaceControl = videoSurfaceControl ?: return
+        val surfaceView = surfaceControlVideoView ?: return
+        val parentSurfaceControl = surfaceView.surfaceControl ?: return
+        
+        SurfaceControl.Transaction()
+            .reparent(surfaceControl, parentSurfaceControl)
+            .setBufferSize(surfaceControl, surfaceView.width, surfaceView.height)
+            .setVisibility(surfaceControl, true)
+            .apply()
+    }
+    
+    /**
+     * Hides the video surface (moves it off-screen).
+     */
+    @RequiresApi(Build.VERSION_CODES.Q)
+    private fun hideVideoSurface() {
+        val surfaceControl = videoSurfaceControl ?: return
+        
+        SurfaceControl.Transaction()
+            .reparent(surfaceControl, null)
+            .setBufferSize(surfaceControl, 0, 0)
+            .setVisibility(surfaceControl, false)
+            .apply()
+    }
+    
+    /**
+     * Updates the buffer size of the video surface.
+     */
+    @RequiresApi(Build.VERSION_CODES.Q)
+    private fun updateVideoSurfaceBufferSize(width: Int, height: Int) {
+        val surfaceControl = videoSurfaceControl ?: return
+        
+        SurfaceControl.Transaction()
+            .setBufferSize(surfaceControl, width, height)
+            .apply()
     }
 
     fun setPlayer(player: ExoPlayer?) {
@@ -68,6 +178,9 @@ class ExoPlayerView @JvmOverloads constructor(context: Context, attrs: Attribute
 
         if (currentPlayer != null) {
             currentPlayer.removeListener(playerListener)
+            if (useSurfaceControl && Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+                currentPlayer.clearVideoSurface()
+            }
         }
 
         playerView.player = player
@@ -75,6 +188,12 @@ class ExoPlayerView @JvmOverloads constructor(context: Context, attrs: Attribute
         if (player != null) {
             player.addListener(playerListener)
             
+            // If using SurfaceControl, set the persistent video surface
+            if (useSurfaceControl && Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+                ensureVideoSurfaceControl()
+                player.setVideoSurface(videoSurface)
+            }
+
             // Apply pending resize mode if we have one
             pendingResizeMode?.let { resizeMode ->
                 playerView.resizeMode = resizeMode
@@ -284,6 +403,74 @@ class ExoPlayerView @JvmOverloads constructor(context: Context, attrs: Attribute
             pendingResizeMode?.let { resizeMode ->
                 playerView.resizeMode = resizeMode
             }
+            
+            // Update video surface size when layout changes
+            if (useSurfaceControl && Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+                surfaceControlVideoView?.let { view ->
+                    if (view.width > 0 && view.height > 0) {
+                        updateVideoSurfaceBufferSize(view.width, view.height)
+                    }
+                }
+            }
+        }
+    }
+    
+    /**
+     * Re-parent the video surface to a different SurfaceView.
+     * This is useful when moving the video to a different view without interrupting playback.
+     * Only works on Android 10+ with SurfaceControl support.
+     */
+    @RequiresApi(Build.VERSION_CODES.Q)
+    fun reparentVideoToSurfaceView(targetSurfaceView: SurfaceView?) {
+        if (!useSurfaceControl) return
+        
+        val surfaceControl = videoSurfaceControl ?: return
+        
+        if (targetSurfaceView == null) {
+            hideVideoSurface()
+            return
+        }
+        
+        val targetSurfaceControl = targetSurfaceView.surfaceControl
+        if (targetSurfaceControl != null) {
+            SurfaceControl.Transaction()
+                .reparent(surfaceControl, targetSurfaceControl)
+                .setBufferSize(surfaceControl, targetSurfaceView.width, targetSurfaceView.height)
+                .setVisibility(surfaceControl, true)
+                .apply()
         }
     }
+    
+    /**
+     * Get the video SurfaceView for external re-parenting operations.
+     */
+    fun getVideoSurfaceView(): SurfaceView? = surfaceControlVideoView
+    
+    /**
+     * Clean up SurfaceControl resources.
+     */
+    private fun releaseSurfaceControl() {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+            videoSurface?.release()
+            videoSurface = null
+            
+            videoSurfaceControl?.release()
+            videoSurfaceControl = null
+        }
+        
+        surfaceControlVideoView = null
+    }
+    
+    override fun onDetachedFromWindow() {
+        super.onDetachedFromWindow()
+        // Note: We don't release SurfaceControl here as it might be re-parented
+        // The parent view should handle cleanup when appropriate
+    }
+    
+    /**
+     * Call this when the view is being permanently destroyed.
+     */
+    fun release() {
+        releaseSurfaceControl()
+    }
 }
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerView.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerView.java
index 539ecfd..aaa2eb8 100644
--- a/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerView.java
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerView.java
@@ -227,7 +227,6 @@ public class ReactExoplayerView extends FrameLayout implements
      */
     private boolean isSeeking = false;
     private long seekPosition = -1;
-    private boolean hasVideoEnded = false;
 
     // Props from React
     private Source source = new Source();
@@ -1225,6 +1224,12 @@ public class ReactExoplayerView extends FrameLayout implements
             adsLoader.release();
             adsLoader = null;
         }
+        
+        // Release SurfaceControl resources
+        if (exoPlayerView != null) {
+            exoPlayerView.release();
+        }
+        
         progressHandler.removeMessages(SHOW_PROGRESS);
         audioBecomingNoisyReceiver.removeListener();
         pictureInPictureReceiver.removeListener();
@@ -1412,7 +1417,6 @@ public class ReactExoplayerView extends FrameLayout implements
                     break;
                 case Player.STATE_READY:
                     text += "ready";
-                    hasVideoEnded = false;
                     eventEmitter.onReadyForDisplay.invoke();
                     onBuffering(false);
                     clearProgressMessageHandler(); // ensure there is no other message
@@ -1431,10 +1435,7 @@ public class ReactExoplayerView extends FrameLayout implements
                 case Player.STATE_ENDED:
                     text += "ended";
                     updateProgress();
-                    if (!hasVideoEnded) {
-                        hasVideoEnded = true;
-                        eventEmitter.onVideoEnd.invoke();
-                    }
+                    eventEmitter.onVideoEnd.invoke();
                     onStopPlayback();
                     setKeepScreenOn(false);
                     break;
@@ -1824,10 +1825,7 @@ public class ReactExoplayerView extends FrameLayout implements
         if (reason == Player.DISCONTINUITY_REASON_AUTO_TRANSITION
                 && player.getRepeatMode() == Player.REPEAT_MODE_ONE) {
             updateProgress();
-            if (!hasVideoEnded) {
-                hasVideoEnded = true;
-                eventEmitter.onVideoEnd.invoke();
-            }
+            eventEmitter.onVideoEnd.invoke();
         }
     }
 
@@ -2038,7 +2036,6 @@ public class ReactExoplayerView extends FrameLayout implements
             }
 
             if (!isSourceEqual) {
-                hasVideoEnded = false;
                 playerNeedsSource = true;
                 initializePlayer();
             }
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/SurfaceControlVideoView.kt b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/SurfaceControlVideoView.kt
new file mode 100644
index 0000000..abe402b
--- /dev/null
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/SurfaceControlVideoView.kt
@@ -0,0 +1,165 @@
+package com.brentvatne.exoplayer
+
+import android.content.Context
+import android.os.Build
+import android.view.Surface
+import android.view.SurfaceControl
+import android.view.SurfaceHolder
+import android.view.SurfaceView
+import androidx.annotation.RequiresApi
+import androidx.media3.exoplayer.ExoPlayer
+
+/**
+ * A SurfaceView wrapper that manages video output using SurfaceControl.
+ * This allows the video surface to be re-parented between different views
+ * without interrupting playback (no black frames).
+ *
+ * Based on ExoPlayer's SurfaceControl demo:
+ * https://github.com/androidx/media/tree/release/demos/surface
+ */
+@RequiresApi(Build.VERSION_CODES.Q)
+class SurfaceControlVideoView(context: Context) : SurfaceView(context) {
+    
+    private var videoSurfaceControl: SurfaceControl? = null
+    private var videoSurface: Surface? = null
+    private var player: ExoPlayer? = null
+    
+    init {
+        holder.addCallback(object : SurfaceHolder.Callback {
+            override fun surfaceCreated(holder: SurfaceHolder) {
+                ensureVideoSurfaceControl()
+                // When the parent SurfaceView is created, reparent the video surface to it
+                reparentToSurface()
+            }
+            
+            override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {
+                // Update the buffer size when the parent surface changes
+                updateBufferSize(width, height)
+            }
+            
+            override fun surfaceDestroyed(holder: SurfaceHolder) {
+                // Don't destroy the video surface - just unparent it
+                reparentToNull()
+            }
+        })
+    }
+    
+    /**
+     * Creates the persistent video SurfaceControl and Surface if not already created.
+     * This surface stays attached to the MediaCodec throughout re-parenting operations.
+     */
+    private fun ensureVideoSurfaceControl() {
+        if (videoSurfaceControl == null) {
+            videoSurfaceControl = SurfaceControl.Builder()
+                .setName("RNVideo-SurfaceControl")
+                .setBufferSize(0, 0)
+                .build()
+            
+            videoSurface = Surface(videoSurfaceControl)
+            
+            // Attach the video surface to the player
+            player?.setVideoSurface(videoSurface)
+        }
+    }
+    
+    /**
+     * Sets the ExoPlayer instance and attaches the video surface to it.
+     */
+    fun setPlayer(player: ExoPlayer?) {
+        val previousPlayer = this.player
+        
+        if (previousPlayer != null && previousPlayer != player) {
+            // Clear the surface from the old player
+            previousPlayer.clearVideoSurface()
+        }
+        
+        this.player = player
+        
+        if (player != null) {
+            ensureVideoSurfaceControl()
+            player.setVideoSurface(videoSurface)
+        }
+    }
+    
+    /**
+     * Re-parents the video SurfaceControl to this SurfaceView.
+     * This is called when the SurfaceView becomes visible or available.
+     */
+    fun reparentToSurface() {
+        val surfaceControl = videoSurfaceControl ?: return
+        val parentSurfaceControl = this.surfaceControl ?: return
+        
+        SurfaceControl.Transaction()
+            .reparent(surfaceControl, parentSurfaceControl)
+            .setBufferSize(surfaceControl, width, height)
+            .setVisibility(surfaceControl, true)
+            .apply()
+    }
+    
+    /**
+     * Re-parents the video SurfaceControl to null (off-screen).
+     * This is called when the SurfaceView is being destroyed or hidden.
+     */
+    fun reparentToNull() {
+        val surfaceControl = videoSurfaceControl ?: return
+        
+        SurfaceControl.Transaction()
+            .reparent(surfaceControl, null)
+            .setBufferSize(surfaceControl, 0, 0)
+            .setVisibility(surfaceControl, false)
+            .apply()
+    }
+    
+    /**
+     * Updates the buffer size of the video SurfaceControl to match the parent surface.
+     */
+    private fun updateBufferSize(width: Int, height: Int) {
+        val surfaceControl = videoSurfaceControl ?: return
+        
+        SurfaceControl.Transaction()
+            .setBufferSize(surfaceControl, width, height)
+            .apply()
+    }
+    
+    /**
+     * Re-parents the video surface to a different SurfaceView.
+     * This is the key method that allows smooth re-parenting without black frames.
+     */
+    fun reparentToSurfaceView(targetSurfaceView: SurfaceView?) {
+        val surfaceControl = videoSurfaceControl ?: return
+        
+        if (targetSurfaceView == null) {
+            reparentToNull()
+            return
+        }
+        
+        val targetSurfaceControl = targetSurfaceView.surfaceControl
+        if (targetSurfaceControl != null) {
+            SurfaceControl.Transaction()
+                .reparent(surfaceControl, targetSurfaceControl)
+                .setBufferSize(surfaceControl, targetSurfaceView.width, targetSurfaceView.height)
+                .setVisibility(surfaceControl, true)
+                .apply()
+        }
+    }
+    
+    /**
+     * Clean up resources when the view is being destroyed permanently.
+     */
+    fun release() {
+        player?.clearVideoSurface()
+        player = null
+        
+        videoSurface?.release()
+        videoSurface = null
+        
+        videoSurfaceControl?.release()
+        videoSurfaceControl = null
+    }
+    
+    override fun onDetachedFromWindow() {
+        // Don't release here - the surface might be re-parented elsewhere
+        super.onDetachedFromWindow()
+    }
+}
+
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/VideoReparentingHelper.kt b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/VideoReparentingHelper.kt
new file mode 100644
index 0000000..21817a3
--- /dev/null
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/VideoReparentingHelper.kt
@@ -0,0 +1,82 @@
+package com.brentvatne.exoplayer
+
+import android.os.Build
+import android.view.View
+import android.view.ViewGroup
+import android.view.SurfaceView
+import androidx.annotation.RequiresApi
+
+/**
+ * Helper class to handle video re-parenting with SurfaceControl.
+ * 
+ * This class provides utilities to detect when a video view is being moved
+ * in the view hierarchy and ensures that the video surface is properly
+ * re-parented using SurfaceControl to avoid black frames.
+ */
+object VideoReparentingHelper {
+    
+    /**
+     * Finds the ExoPlayerView in a view hierarchy.
+     */
+    fun findExoPlayerView(view: View): ExoPlayerView? {
+        if (view is ExoPlayerView) {
+            return view
+        }
+        
+        if (view is ViewGroup) {
+            for (i in 0 until view.childCount) {
+                val child = view.getChildAt(i)
+                val found = findExoPlayerView(child)
+                if (found != null) {
+                    return found
+                }
+            }
+        }
+        
+        return null
+    }
+    
+    /**
+     * Handles re-parenting of a view that contains video.
+     * This should be called before the view is moved in the hierarchy.
+     * 
+     * @param view The view being re-parented
+     * @return true if a video was found and prepared for re-parenting
+     */
+    @RequiresApi(Build.VERSION_CODES.Q)
+    fun prepareForReparenting(view: View): ExoPlayerView? {
+        val exoPlayerView = findExoPlayerView(view)
+        if (exoPlayerView != null && Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+            // Video surface will maintain its content during re-parenting
+            // No action needed - the SurfaceControl will handle it automatically
+        }
+        return exoPlayerView
+    }
+    
+    /**
+     * Called after a view has been re-parented to ensure video rendering is restored.
+     * 
+     * @param view The view that was re-parented
+     */
+    @RequiresApi(Build.VERSION_CODES.Q)
+    fun onReparented(view: View) {
+        val exoPlayerView = findExoPlayerView(view)
+        if (exoPlayerView != null && Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+            // Ensure the video surface is visible and properly sized
+            val videoSurfaceView = exoPlayerView.getVideoSurfaceView()
+            if (videoSurfaceView != null) {
+                // Request layout to ensure proper sizing
+                videoSurfaceView.requestLayout()
+                exoPlayerView.requestLayout()
+            }
+        }
+    }
+    
+    /**
+     * Detects if a view contains a video player.
+     */
+    fun containsVideoPlayer(view: View): Boolean {
+        return findExoPlayerView(view) != null
+    }
+}
+
